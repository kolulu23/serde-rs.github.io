{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#serde","title":"Serde","text":"<p>Serde is a framework for serializing and deserializing Rust data structures efficiently and generically.</p> <p>The Serde ecosystem consists of data structures that know how to serialize and deserialize themselves along with data formats that know how to serialize and deserialize other things. Serde provides the layer by which these two groups interact with each other, allowing any supported data structure to be serialized and deserialized using any supported data format.</p>"},{"location":"#design","title":"Design","text":"<p>Where many other languages rely on runtime reflection for serializing data, Serde is instead built on Rust's powerful trait system. A data structure that knows how to serialize and deserialize itself is one that implements Serde's <code>Serialize</code> and <code>Deserialize</code> traits (or uses Serde's derive attribute to automatically generate implementations at compile time). This avoids any overhead of reflection or runtime type information. In fact in many situations the interaction between data structure and data format can be completely optimized away by the Rust compiler, leaving Serde serialization to perform the same speed as a handwritten serializer for the specific selection of data structure and data format.</p>"},{"location":"#data-formats","title":"Data formats","text":"<p>The following is a partial list of data formats that have been implemented for Serde by the community.</p> <ul> <li>JSON, the ubiquitous JavaScript Object Notation used by many HTTP APIs.</li> <li>Postcard, a no_std and embedded-systems friendly compact binary format.</li> <li>CBOR, a Concise Binary Object Representation designed for small message size   without the need for version negotiation.</li> <li>YAML, a self-proclaimed human-friendly configuration language that ain't   markup language.</li> <li>MessagePack, an efficient binary format that resembles a compact JSON.</li> <li>TOML, a minimal configuration format used by Cargo.</li> <li>Pickle, a format common in the Python world.</li> <li>RON, a Rusty Object Notation.</li> <li>BSON, the data storage and network transfer format used by MongoDB.</li> <li>Avro, a binary format used within Apache Hadoop, with support for schema   definition.</li> <li>JSON5, a superset of JSON including some productions from ES5.</li> <li>URL query strings, in the x-www-form-urlencoded format.</li> <li>Starlark, the format used for describing build targets by the Bazel and Buck   build systems. (serialization only)</li> <li>Envy, a way to deserialize environment variables into Rust structs.   (deserialization only)</li> <li>Envy Store, a way to deserialize AWS Parameter Store parameters into Rust   structs. (deserialization only)</li> <li>S-expressions, the textual representation of code and data used by the Lisp   language family.</li> <li>D-Bus's binary wire format.</li> <li>FlexBuffers, the schemaless cousin of Google's FlatBuffers zero-copy   serialization format.</li> <li>Bencode, a simple binary format used in the BitTorrent protocol.</li> <li>Token streams, for processing Rust procedural macro input. (deserialization   only)</li> <li>DynamoDB Items, the format used by rusoto_dynamodb to transfer data to   and from DynamoDB.</li> <li>Hjson, a syntax extension to JSON designed around human reading and editing.   (deserialization only)</li> </ul>"},{"location":"#data-structures","title":"Data structures","text":"<p>Out of the box, Serde is able to serialize and deserialize common Rust data types in any of the above formats. For example <code>String</code>, <code>&amp;str</code>, <code>usize</code>, <code>Vec&lt;T&gt;</code>, <code>HashMap&lt;K,V&gt;</code> are all supported. In addition, Serde provides a derive macro to generate serialization implementations for structs in your own program. Using the derive macro goes like this:</p> <p>!PLAYGROUND 72755f28f99afc95e01d63174b28c1f5 <pre><code>use serde::{Serialize, Deserialize};\n#[derive(Serialize, Deserialize, Debug)]\nstruct Point {\nx: i32,\ny: i32,\n}\nfn main() {\nlet point = Point { x: 1, y: 2 };\n// Convert the Point to a JSON string.\nlet serialized = serde_json::to_string(&amp;point).unwrap();\n// Prints serialized = {\"x\":1,\"y\":2}\nprintln!(\"serialized = {}\", serialized);\n// Convert the JSON string back to a Point.\nlet deserialized: Point = serde_json::from_str(&amp;serialized).unwrap();\n// Prints deserialized = Point { x: 1, y: 2 }\nprintln!(\"deserialized = {:?}\", deserialized);\n}\n</code></pre></p>"},{"location":"data-model/","title":"Serde data model","text":"<p>The Serde data model is the API by which data structures and data formats interact. You can think of it as Serde's type system.</p> <p>In code, the serialization half of the Serde data model is defined by the [<code>Serializer</code>] trait and the deserialization half is defined by the [<code>Deserializer</code>] trait. These are a way of mapping every Rust data structure into one of 29 possible types. Each method of the <code>Serializer</code> trait corresponds to one of the types of the data model.</p> <p>When serializing a data structure to some format, the [<code>Serialize</code>] implementation for the data structure is responsible for mapping the data structure into the Serde data model by invoking exactly one of the <code>Serializer</code> methods, while the <code>Serializer</code> implementation for the data format is responsible for mapping the Serde data model into the intended output representation.</p> <p>When deserializing a data structure from some format, the [<code>Deserialize</code>] implementation for the data structure is responsible for mapping the data structure into the Serde data model by passing to the <code>Deserializer</code> a [<code>Visitor</code>] implementation that can receive the various types of the data model, while the <code>Deserializer</code> implementation for the data format is responsible for mapping the input data into the Serde data model by invoking exactly one of the <code>Visitor</code> methods.</p>"},{"location":"data-model/#types","title":"Types","text":"<p>The Serde data model is a simplified form of Rust's type system. It consists of the following 29 types:</p> <ul> <li>14 primitive types</li> <li>bool</li> <li>i8, i16, i32, i64, i128</li> <li>u8, u16, u32, u64, u128</li> <li>f32, f64</li> <li>char</li> <li>string</li> <li>UTF-8 bytes with a length and no null terminator. May contain 0-bytes.</li> <li>When serializing, all strings are handled equally. When deserializing, there     are three flavors of strings: transient, owned, and borrowed. This     distinction is explained in Understanding deserializer lifetimes and is a     key way that Serde enabled efficient zero-copy deserialization.</li> <li>byte array - [u8]</li> <li>Similar to strings, during deserialization byte arrays can be transient,     owned, or borrowed.</li> <li>option</li> <li>Either none or some value.</li> <li>unit</li> <li>The type of <code>()</code> in Rust. It represents an anonymous value containing no     data.</li> <li>unit_struct</li> <li>For example <code>struct Unit</code> or <code>PhantomData&lt;T&gt;</code>. It represents a named value     containing no data.</li> <li>unit_variant</li> <li>For example the <code>E::A</code> and <code>E::B</code> in <code>enum E { A, B }</code>.</li> <li>newtype_struct</li> <li>For example <code>struct Millimeters(u8)</code>.</li> <li>newtype_variant</li> <li>For example the <code>E::N</code> in <code>enum E { N(u8) }</code>.</li> <li>seq</li> <li>A variably sized heterogeneous sequence of values, for example <code>Vec&lt;T&gt;</code> or     <code>HashSet&lt;T&gt;</code>. When serializing, the length may or may not be known before     iterating through all the data. When deserializing, the length is determined     by looking at the serialized data. Note that a homogeneous Rust collection     like <code>vec![Value::Bool(true), Value::Char('c')]</code> may serialize as a     heterogeneous Serde seq, in this case containing a Serde bool followed by a     Serde char.</li> <li>tuple</li> <li>A statically sized heterogeneous sequence of values for which the length     will be known at deserialization time without looking at the serialized     data, for example <code>(u8,)</code> or <code>(String, u64, Vec&lt;T&gt;)</code> or <code>[u64; 10]</code>.</li> <li>tuple_struct</li> <li>A named tuple, for example <code>struct Rgb(u8, u8, u8)</code>.</li> <li>tuple_variant</li> <li>For example the <code>E::T</code> in <code>enum E { T(u8, u8) }</code>.</li> <li>map</li> <li>A variably sized heterogeneous key-value pairing, for example <code>BTreeMap&lt;K,     V&gt;</code>. When serializing, the length may or may not be known before iterating     through all the entries. When deserializing, the length is determined by     looking at the serialized data.</li> <li>struct</li> <li>A statically sized heterogeneous key-value pairing in which the keys are     compile-time constant strings and will be known at deserialization time     without looking at the serialized data, for example <code>struct S { r: u8, g:     u8, b: u8 }</code>.</li> <li>struct_variant</li> <li>For example the <code>E::S</code> in <code>enum E { S { r: u8, g: u8, b: u8 } }</code>.</li> </ul>"},{"location":"data-model/#mapping-into-the-data-model","title":"Mapping into the data model","text":"<p>In the case of most Rust types, their mapping into the Serde data model is straightforward. For example the Rust <code>bool</code> type corresponds to Serde's bool type. The Rust tuple struct <code>Rgb(u8, u8, u8)</code> corresponds to Serde's tuple struct type.</p> <p>But there is no fundamental reason that these mappings need to be straightforward. The [<code>Serialize</code>] and [<code>Deserialize</code>] traits can perform any mapping between Rust type and Serde data model that is appropriate for the use case.</p> <p>As an example, consider Rust's [<code>std::ffi::OsString</code>] type. This type represents a platform-native string. On Unix systems they are arbitrary non-zero bytes and on Windows systems they are arbitrary non-zero 16-bit values. It may seem natural to map <code>OsString</code> into the Serde data model as one of the following types:</p> <ul> <li>As a Serde string. Unfortunately serialization would be brittle because an   <code>OsString</code> is not guaranteed to be representable in UTF-8 and deserialization   would be brittle because Serde strings are allowed to contain 0-bytes.</li> <li>As a Serde byte array. This fixes both problem with using string, but now   if we serialize an <code>OsString</code> on Unix and deserialize it on Windows we end up   with the wrong string.</li> </ul> <p>Instead the <code>Serialize</code> and <code>Deserialize</code> impls for <code>OsString</code> map into the Serde data model by treating <code>OsString</code> as a Serde enum. Effectively it acts as though <code>OsString</code> were defined as the following type, even though this does not match its definition on any individual platform.</p> <pre><code># #![allow(dead_code)]\n#\nenum OsString {\nUnix(Vec&lt;u8&gt;),\nWindows(Vec&lt;u16&gt;),\n// and other platforms\n}\n#\n# fn main() {}\n</code></pre> <p>The flexibility around mapping into the Serde data model is profound and powerful. When implementing <code>Serialize</code> and <code>Deserialize</code>, be aware of the broader context of your type that may make the most instinctive mapping not the best choice.</p>"},{"location":"derive/","title":"Using derive","text":"<p>Serde provides a derive macro to generate implementations of the <code>Serialize</code> and <code>Deserialize</code> traits for data structures defined in your crate, allowing them to be represented conveniently in all of Serde's data formats.</p> <p>You only need to set this up if your code is using <code>#[derive(Serialize, Deserialize)]</code>.</p> <p>This functionality is based on Rust's <code>#[derive]</code> mechanism, just like what you would use to automatically derive implementations of the built-in <code>Clone</code>, <code>Copy</code>, <code>Debug</code>, or other traits. It is able to generate implementations for most structs and enums including ones with elaborate generic types or trait bounds. On rare occasions, for an especially convoluted type you may need to implement the traits manually.</p> <p>These derives require a Rust compiler version 1.31 or newer.</p> <p>!CHECKLIST - Add <code>serde = { version = \"1.0\", features = [\"derive\"] }</code> as a dependency in   Cargo.toml. - Ensure that all other Serde-based dependencies (for example serde_json) are on   a version that is compatible with serde 1.0. - On structs and enums that you want to serialize, import the derive macro as   <code>use serde::Serialize;</code> within the same module and write   <code>#[derive(Serialize)]</code> on the struct or enum. - Similarly import <code>use serde::Deserialize;</code> and write <code>#[derive(Deserialize)]</code>   on structs and enums that you want to deserialize.</p> <p>Here is the <code>Cargo.toml</code>:</p> <p>!FILENAME Cargo.toml <pre><code>[package]\nname = \"my-crate\"\nversion = \"0.1.0\"\nauthors = [\"Me &lt;user@rust-lang.org&gt;\"]\n[dependencies]\nserde = { version = \"1.0\", features = [\"derive\"] }\n# serde_json is just for the example, not required in general\nserde_json = \"1.0\"\n</code></pre></p> <p>Now the <code>src/main.rs</code> which uses Serde's custom derives:</p> <p>!FILENAME src/main.rs !PLAYGROUND 1dbc76000e9875fac72c2865748842d7 <pre><code>use serde::{Serialize, Deserialize};\n#[derive(Serialize, Deserialize, Debug)]\nstruct Point {\nx: i32,\ny: i32,\n}\nfn main() {\nlet point = Point { x: 1, y: 2 };\nlet serialized = serde_json::to_string(&amp;point).unwrap();\nprintln!(\"serialized = {}\", serialized);\nlet deserialized: Point = serde_json::from_str(&amp;serialized).unwrap();\nprintln!(\"deserialized = {:?}\", deserialized);\n}\n</code></pre></p> <p>Here is the output:</p> <pre><code>$ cargo run\nserialized = {\"x\":1,\"y\":2}\ndeserialized = Point { x: 1, y: 2 }\n</code></pre>"},{"location":"derive/#troubleshooting","title":"Troubleshooting","text":"<p>Sometimes you may see compile-time errors that tell you:</p> <pre><code>the trait `serde::ser::Serialize` is not implemented for `...`\n</code></pre> <p>even though the struct or enum clearly has <code>#[derive(Serialize)]</code> on it.</p> <p>This almost always means that you are using libraries that depend on incompatible versions of Serde. You may be depending on serde 1.0 in your Cargo.toml but using some other library that depends on serde 0.9. So the <code>Serialize</code> trait from serde 1.0 may be implemented, but the library expects an implementation of the <code>Serialize</code> trait from serde 0.9. From the Rust compiler's perspective these are totally different traits.</p> <p>The fix is to upgrade or downgrade libraries as appropriate until the Serde versions match. The <code>cargo tree -d</code> command is helpful for finding all the places that duplicate dependencies are being pulled in.</p>"},{"location":"feature-flags/","title":"Feature flags","text":"<p>The <code>serde</code> crate defines some Cargo features to enable using Serde in a variety of freestanding environments.</p> <p>Building Serde with <code>default-features = false</code>, you will receive a stock <code>no_std</code> Serde with no support for any of the collection types.</p>"},{"location":"feature-flags/#-feature-derive","title":"--feature derive","text":"<p>Provide derive macros for the Serialize and Deserialize traits.</p> <p>This is behind a feature because the derive macro implementation takes some extra time to compile.</p>"},{"location":"feature-flags/#-feature-std","title":"--feature std","text":"<p>This feature is enabled by default.</p> <p>Provide impls for common standard library types like Vec&lt;T&gt; and HashMap&lt;K, V&gt;. Requires a dependency on the Rust standard library.</p> <p>See no-std support for details.</p>"},{"location":"feature-flags/#-feature-unstable","title":"--feature unstable","text":"<p>Provide impls for types that require unstable functionality. For tracking and discussion of unstable functionality please refer to serde-rs/serde#812.</p>"},{"location":"feature-flags/#-features-alloc","title":"--features alloc","text":"<p>Provide impls for types in the Rust core allocation and collections library including String, Box&lt;T&gt;, Vec&lt;T&gt;, and Cow&lt;T&gt;. This is a subset of std but may be enabled without depending on all of std.</p> <p>Requires a dependency on the core allocation library.</p> <p>See no-std support for details.</p>"},{"location":"feature-flags/#-features-rc","title":"--features rc","text":"<p>Opt into impls for Rc&lt;T&gt; and Arc&lt;T&gt;. Serializing and deserializing these types does not preserve identity and may result in multiple copies of the same data. Be sure that this is what you want before enabling this feature.</p> <p>Serializing a data structure containing reference-counted pointers will serialize a copy of the inner value of the pointer each time a pointer is referenced within the data structure. Serialization will not attempt to deduplicate these repeated data.</p> <p>Deserializing a data structure containing reference-counted pointers will not attempt to deduplicate references to the same data. Every deserialized pointer will end up with a strong count of 1.</p>"},{"location":"help/","title":"Getting help","text":"<p>Serde is one of the most widely used Rust libraries so any place that Rustaceans congregate will be able to help you out. For chat, consider trying the #rust-questions or #rust-beginners channels of the unofficial community Discord (invite: https://discord.gg/rust-lang-community), the #rust-usage or #beginners channels of the official Rust Project Discord (invite: https://discord.gg/rust-lang), or the #general stream in Zulip. For asynchronous, consider the [rust] tag on StackOverflow, the /r/rust subreddit which has a pinned weekly easy questions post, or the Rust Discourse forum.</p>"},{"location":"lifetimes/","title":"Understanding deserializer lifetimes","text":"<p>The [<code>Deserialize</code>] and [<code>Deserializer</code>] traits both have a lifetime called <code>'de</code>, as do some of the other deserialization-related traits.</p> <pre><code># use serde::Deserializer;\n#\ntrait Deserialize&lt;'de&gt;: Sized {\nfn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Self, D::Error&gt;\nwhere\nD: Deserializer&lt;'de&gt;;\n}\n#\n# fn main() {}\n</code></pre> <p>This lifetime is what enables Serde to safely perform efficient zero-copy deserialization across a variety of data formats, something that would be impossible or recklessly unsafe in languages other than Rust.</p> <pre><code># #![allow(dead_code)]\n#\n# use serde::Deserialize;\n#\n#[derive(Deserialize)]\nstruct User&lt;'a&gt; {\nid: u32,\nname: &amp;'a str,\nscreen_name: &amp;'a str,\nlocation: &amp;'a str,\n}\n#\n# fn main() {}\n</code></pre> <p>Zero-copy deserialization means deserializing into a data structure, like the <code>User</code> struct above, that borrows string or byte array data from the string or byte array holding the input. This avoids allocating memory to store a string for each individual field and then copying string data out of the input over to the newly allocated field. Rust guarantees that the input data outlives the period during which the output data structure is in scope, meaning it is impossible to have dangling pointer errors as a result of losing the input data while the output data structure still refers to it.</p>"},{"location":"lifetimes/#trait-bounds","title":"Trait bounds","text":"<p>There are two main ways to write <code>Deserialize</code> trait bounds, whether on an impl block or a function or anywhere else.</p> <ul> <li> <p><code>&lt;'de, T&gt; where T: Deserialize&lt;'de&gt;</code></p> <p>This means \"T can be deserialized from some lifetime.\" The caller gets to decide what lifetime that is. Typically this is used when the caller also provides the data that is being deserialized from, for example in a function like [<code>serde_json::from_str</code>]. In that case the input data must also have lifetime <code>'de</code>, for example it could be <code>&amp;'de str</code>.</p> </li> <li> <p><code>&lt;T&gt; where T: DeserializeOwned</code></p> <p>This means \"T can be deserialized from any lifetime.\" The callee gets to decide what lifetime. Usually this is because the data that is being deserialized from is going to be thrown away before the function returns, so T must not be allowed to borrow from it. For example a function that accepts base64-encoded data as input, decodes it from base64, deserializes a value of type T, then throws away the result of base64 decoding. Another common use of this bound is functions that deserialize from an IO stream, such as [<code>serde_json::from_reader</code>].</p> <p>To say it more technically, the [<code>DeserializeOwned</code>] trait is equivalent to the higher-rank trait bound <code>for&lt;'de&gt; Deserialize&lt;'de&gt;</code>. The only difference is <code>DeserializeOwned</code> is more intuitive to read. It means T owns all the data that gets deserialized.</p> </li> </ul> <p>Note that <code>&lt;T&gt; where T: Deserialize&lt;'static&gt;</code> is never what you want. Also <code>Deserialize&lt;'de&gt; + 'static</code> is never what you want. Generally writing <code>'static</code> anywhere near <code>Deserialize</code> is a sign of being on the wrong track. Use one of the above bounds instead.</p>"},{"location":"lifetimes/#transient-borrowed-and-owned-data","title":"Transient, borrowed, and owned data","text":"<p>The Serde data model has three flavors of strings and byte arrays during deserialization. They correspond to different methods on the [<code>Visitor</code>] trait.</p> <ul> <li>Transient \u2014 [<code>visit_str</code>] accepts a <code>&amp;str</code>.</li> <li>Borrowed \u2014 [<code>visit_borrowed_str</code>] accepts a <code>&amp;'de str</code>.</li> <li>Owned \u2014 [<code>visit_string</code>] accepts a <code>String</code>.</li> </ul> <p>Transient data is not guaranteed to last beyond the method call it is passed to. Often this is sufficient, for example when deserializing something like an IP address from a Serde string using the [<code>FromStr</code>] trait. When it is not sufficient, the data can be copied by calling [<code>to_owned()</code>]. Deserializers commonly use transient data when input from an IO stream is being buffered in memory before being passed to the <code>Visitor</code>, or when escape sequences are being processed so the resulting string is not present verbatim in the input.</p> <p>Borrowed data is guaranteed to live at least as long as the <code>'de</code> lifetime parameter of the <code>Deserializer</code>. Not all deserializers support handing out borrowed data. For example when deserializing from an IO stream no data can be borrowed.</p> <p>Owned data is guaranteed to live as long as the [<code>Visitor</code>] wants it to. Some visitors benefit from receiving owned data. For example the <code>Deserialize</code> impl for Rust's <code>String</code> type benefits from being given ownership of the Serde string data that has been deserialized.</p>"},{"location":"lifetimes/#the-deserializede-lifetime","title":"The Deserialize&lt;'de&gt; lifetime","text":"<p>This lifetime records the constraints on how long data borrowed by this type must be valid.</p> <p>Every lifetime of data borrowed by this type must be a bound on the <code>'de</code> lifetime of its <code>Deserialize</code> impl. If this type borrows data with lifetime <code>'a</code>, then <code>'de</code> must be constrained to outlive <code>'a</code>.</p> <pre><code># #![allow(dead_code)]\n#\n# trait Deserialize&lt;'de&gt; {}\n#\nstruct S&lt;'a, 'b, T&gt; {\na: &amp;'a str,\nb: &amp;'b str,\nbb: &amp;'b str,\nt: T,\n}\nimpl&lt;'de: 'a + 'b, 'a, 'b, T&gt; Deserialize&lt;'de&gt; for S&lt;'a, 'b, T&gt;\nwhere\nT: Deserialize&lt;'de&gt;,\n{\n/* ... */\n}\n#\n# fn main() {}\n</code></pre> <p>If this type does not borrow any data from the <code>Deserializer</code>, there are simply no bounds on the <code>'de</code> lifetime. Such types automatically implement the [<code>DeserializeOwned</code>] trait.</p> <pre><code># #![allow(dead_code)]\n#\n# pub trait Deserialize&lt;'de&gt; {}\n#\nstruct S {\nowned: String,\n}\nimpl&lt;'de&gt; Deserialize&lt;'de&gt; for S {\n/* ... */\n}\n#\n# fn main() {}\n</code></pre> <p>The <code>'de</code> lifetime should not appear in the type to which the <code>Deserialize</code> impl applies.</p> <pre><code>- // Do not do this. Sooner or later you will be sad.\n- impl&lt;'de&gt; Deserialize&lt;'de&gt; for Q&lt;'de&gt; {\n+ // Do this instead.\n+ impl&lt;'de: 'a, 'a&gt; Deserialize&lt;'de&gt; for Q&lt;'a&gt; {\n</code></pre>"},{"location":"lifetimes/#the-deserializerde-lifetime","title":"The Deserializer&lt;'de&gt; lifetime","text":"<p>This is the lifetime of data that can be borrowed from the <code>Deserializer</code>.</p> <pre><code># #![allow(dead_code)]\n#\n# pub trait Deserializer&lt;'de&gt; {}\n#\nstruct MyDeserializer&lt;'de&gt; {\ninput_data: &amp;'de [u8],\npos: usize,\n}\nimpl&lt;'de&gt; Deserializer&lt;'de&gt; for MyDeserializer&lt;'de&gt; {\n/* ... */\n}\n#\n# fn main() {}\n</code></pre> <p>If the <code>Deserializer</code> never invokes [<code>visit_borrowed_str</code>] or [<code>visit_borrowed_bytes</code>], the <code>'de</code> lifetime will be an unconstrained lifetime parameter.</p> <pre><code># #![allow(dead_code)]\n#\n# use std::io;\n#\n# pub trait Deserializer&lt;'de&gt; {}\n#\nstruct MyDeserializer&lt;R&gt; {\nread: R,\n}\nimpl&lt;'de, R&gt; Deserializer&lt;'de&gt; for MyDeserializer&lt;R&gt;\nwhere\nR: io::Read,\n{\n/* ... */\n}\n#\n# fn main() {}\n</code></pre>"},{"location":"lifetimes/#borrowing-data-in-a-derived-impl","title":"Borrowing data in a derived impl","text":"<p>Fields of type <code>&amp;str</code> and <code>&amp;[u8]</code> are implicitly borrowed from the input data by Serde. Any other type of field can opt in to borrowing by using the <code>#[serde(borrow)]</code> attribute.</p> <pre><code># #![allow(dead_code)]\n#\nuse serde::Deserialize;\nuse std::borrow::Cow;\n#[derive(Deserialize)]\nstruct Inner&lt;'a, 'b&gt; {\n// &amp;str and &amp;[u8] are implicitly borrowed.\nusername: &amp;'a str,\n// Other types must be borrowed explicitly.\n#[serde(borrow)]\ncomment: Cow&lt;'b, str&gt;,\n}\n#[derive(Deserialize)]\nstruct Outer&lt;'a, 'b, 'c&gt; {\nowned: String,\n#[serde(borrow)]\ninner: Inner&lt;'a, 'b&gt;,\n// This field is never borrowed.\nnot_borrowed: Cow&lt;'c, str&gt;,\n}\n#\n# fn main() {}\n</code></pre> <p>This attribute works by placing bounds on the <code>'de</code> lifetime of the generated <code>Deserialize</code> impl. For example the impl for the struct <code>Outer</code> defined above looks like this:</p> <pre><code># #![allow(dead_code)]\n#\n# use std::borrow::Cow;\n#\n# trait Deserialize&lt;'de&gt; {}\n#\n# struct Inner&lt;'a, 'b&gt; {\n#     username: &amp;'a str,\n#     comment: Cow&lt;'b, str&gt;,\n# }\n#\n# struct Outer&lt;'a, 'b, 'c&gt; {\n#     owned: String,\n#     inner: Inner&lt;'a, 'b&gt;,\n#     not_borrowed: Cow&lt;'c, str&gt;,\n# }\n#\n// The lifetimes 'a and 'b are borrowed while 'c is not.\nimpl&lt;'de: 'a + 'b, 'a, 'b, 'c&gt; Deserialize&lt;'de&gt; for Outer&lt;'a, 'b, 'c&gt; {\n/* ... */\n}\n#\n# fn main() {}\n</code></pre> <p>The attribute may specify explicitly which lifetimes should be borrowed.</p> <pre><code># #![allow(dead_code)]\n#\n# use serde::Deserialize;\n#\nuse std::marker::PhantomData;\n// This struct borrows the first two lifetimes but not the third.\n#[derive(Deserialize)]\nstruct Three&lt;'a, 'b, 'c&gt; {\na: &amp;'a str,\nb: &amp;'b str,\nc: PhantomData&lt;&amp;'c str&gt;,\n}\n#[derive(Deserialize)]\nstruct Example&lt;'a, 'b, 'c&gt; {\n// Borrow 'a and 'b only, not 'c.\n#[serde(borrow = \"'a + 'b\")]\nthree: Three&lt;'a, 'b, 'c&gt;,\n}\n#\n# fn main() {}\n</code></pre>"},{"location":"no-std/","title":"No-std support","text":"<p>The <code>serde</code> crate has a Cargo feature named <code>\"std\"</code> that is enabled by default. In order to use Serde in a no_std context this feature needs to be disabled. Modify your Serde dependency in Cargo.toml to opt out of enabled-by-default features.</p> <pre><code>[dependencies]\nserde = { version = \"1.0\", default-features = false }\n</code></pre> <p>Be aware that Cargo features are unioned together across your entire dependency graph. That means if any other crate you depend on has not opted out of Serde's default features, you will build Serde with the std feature enabled whether or not your direct dependency on Serde has <code>default-features = false</code>.</p> <p>In particular, a dependency on <code>serde_json</code> always needs Serde built with std. If you need JSON support without a standard library, please use [<code>serde-json-core</code>] instead of <code>serde_json</code>.</p>"},{"location":"no-std/#derive","title":"Derive","text":"<p>The <code>#[derive(Serialize, Deserialize)]</code> derive macros work just the same in a no-std crate.</p> <pre><code>[dependencies]\nserde = { version = \"1.0\", default-features = false, features = [\"derive\"] }\n</code></pre> <p>Some deserialization features that require a heap-allocated temporary buffer will not be available in no-std mode without a memory allocator. In particular untagged enums cannot be deserialized.</p>"},{"location":"no-std/#memory-allocation","title":"Memory allocation","text":"<p>Opting out of the <code>\"std\"</code> feature of Serde removes support for any standard library data structures that involve heap memory allocation, including <code>String</code> and <code>Vec&lt;T&gt;</code>. It also removes some features of <code>derive(Deserialize)</code> including untagged enums.</p> <p>You can opt back in to these impls in an unstable way by enabling the <code>\"alloc\"</code> Cargo feature. This configuration provides integration for heap-allocated collections without depending on the rest of the Rust standard library.</p> <pre><code>[dependencies]\nserde = { version = \"1.0\", default-features = false, features = [\"alloc\"] }\n</code></pre>"},{"location":"attributes/","title":"Attributes","text":"<p>Attributes are used to customize the <code>Serialize</code> and <code>Deserialize</code> implementations produced by Serde's derive. They require a Rust compiler version 1.15 or newer.</p> <p>There are three categories of attributes:</p> <ul> <li>Container attributes \u2014 apply to a struct or enum declaration.</li> <li>Variant attributes \u2014 apply to a variant of an enum.</li> <li>Field attributes \u2014 apply to one field in a struct or in an enum variant.</li> </ul> <pre><code># use serde::{Serialize, Deserialize};\n#\n#[derive(Serialize, Deserialize)]\n#[serde(deny_unknown_fields)]  // &lt;-- this is a container attribute\nstruct S {\n#[serde(default)]  // &lt;-- this is a field attribute\nf: i32,\n}\n#[derive(Serialize, Deserialize)]\n#[serde(rename = \"e\")]  // &lt;-- this is also a container attribute\nenum E {\n#[serde(rename = \"a\")]  // &lt;-- this is a variant attribute\nA(String),\n}\n#\n# fn main() {}\n</code></pre> <p>Note that a single struct, enum, variant, or field may have multiple attributes on it.</p>"},{"location":"attributes/container-attrs/","title":"Container attributes","text":"<p>Serialize and deserialize this struct or enum with the given name instead of   its Rust name.</p> <p>Allows specifying independent names for serialization vs deserialization:</p> <ul> <li><code>#[serde(rename(serialize = \"ser_name\"))]</code></li> <li><code>#[serde(rename(deserialize = \"de_name\"))]</code></li> <li> <p><code>#[serde(rename(serialize = \"ser_name\", deserialize = \"de_name\"))]</code></p> </li> <li> </li> </ul> <p>Rename all the fields (if this is a struct) or variants (if this is an enum)   according to the given case convention. The possible values are <code>\"lowercase\"</code>,   <code>\"UPPERCASE\"</code>, <code>\"PascalCase\"</code>, <code>\"camelCase\"</code>, <code>\"snake_case\"</code>,   <code>\"SCREAMING_SNAKE_CASE\"</code>, <code>\"kebab-case\"</code>, <code>\"SCREAMING-KEBAB-CASE\"</code>.</p> <p>Allows specifying independent cases for serialization vs deserialization:</p> <ul> <li><code>#[serde(rename_all(serialize = \"...\"))]</code></li> <li><code>#[serde(rename_all(deserialize = \"...\"))]</code></li> <li> <p><code>#[serde(rename_all(serialize = \"...\", deserialize = \"...\"))]</code></p> </li> <li> </li> </ul> <p>Always error during deserialization when encountering unknown fields. When   this attribute is not present, by default unknown fields are ignored for   self-describing formats like JSON.</p> <p>Note: this attribute is not supported in combination with [<code>flatten</code>],   neither on the outer struct nor on the flattened field.</p> <ul> <li> </li> </ul> <p>Use the internally tagged enum representation for this enum, with the given   tag. See enum representations for details on this   representation.</p> <ul> <li> </li> </ul> <p>Use the adjacently tagged enum representation for this enum, with the given   field names for the tag and content. See enum   representations for details on this representation.</p> <ul> <li> </li> </ul> <p>Use the untagged enum representation for this enum. See enum   representations for details on this representation.</p> <ul> <li> </li> </ul> <p>Where-clause for the <code>Serialize</code> and <code>Deserialize</code> impls. This replaces any   trait bounds inferred by Serde.</p> <p>Allows specifying independent bounds for serialization vs deserialization:</p> <ul> <li><code>#[serde(bound(serialize = \"T: MySerTrait\"))]</code></li> <li><code>#[serde(bound(deserialize = \"T: MyDeTrait\"))]</code></li> <li> <p><code>#[serde(bound(serialize = \"T: MySerTrait\", deserialize = \"T: MyDeTrait\"))]</code></p> </li> <li> </li> </ul> <p>When deserializing, any missing fields should be filled in from the struct's   implementation of <code>Default</code>. Only allowed on structs.</p> <ul> <li> </li> </ul> <p>When deserializing, any missing fields should be filled in from the object   returned by the given function or method. The function must be callable as   <code>fn() -&gt; T</code>. For example <code>default = \"my_default\"</code> would invoke <code>my_default()</code>   and <code>default = \"SomeTrait::some_default\"</code> would invoke   <code>SomeTrait::some_default()</code>. Only allowed on structs.</p> <ul> <li> </li> </ul> <p>This is used for deriving <code>Serialize</code> and <code>Deserialize</code> for remote   types.</p> <ul> <li> </li> </ul> <p>Serialize and deserialize a newtype struct or a braced struct with one field   exactly the same as if its one field were serialized and deserialized by   itself. Analogous to <code>#[repr(transparent)]</code>.</p> <ul> <li> </li> </ul> <p>Deserialize this type by deserializing into <code>FromType</code>, then converting. This   type must implement <code>From&lt;FromType&gt;</code>, and <code>FromType</code> must implement   <code>Deserialize</code>.</p> <ul> <li> </li> </ul> <p>Deserialize this type by deserializing into <code>FromType</code>, then converting   fallibly. This type must implement <code>TryFrom&lt;FromType&gt;</code> with an error type that   implements <code>Display</code>, and <code>FromType</code> must implement <code>Deserialize</code>.</p> <ul> <li> </li> </ul> <p>Serialize this type by converting it into the specified <code>IntoType</code> and   serializing that. This type must implement <code>Clone</code> and <code>Into&lt;IntoType&gt;</code>, and   <code>IntoType</code> must implement <code>Serialize</code>.</p> <ul> <li> </li> </ul> <p>Specify a path to the <code>serde</code> crate instance to use when referring to Serde   APIs from generated code. This is normally only applicable when invoking   re-exported Serde derives from a public macro in a different crate.</p>"},{"location":"attributes/container-attrs/#serderename-name-rename","title":"<code>#[serde(rename = \"name\")]</code> {#rename}","text":""},{"location":"attributes/container-attrs/#serderename_all-rename_all","title":"<code>#[serde(rename_all = \"...\")]</code> {#rename_all}","text":""},{"location":"attributes/container-attrs/#serdedeny_unknown_fields-deny_unknown_fields","title":"<code>#[serde(deny_unknown_fields)]</code> {#deny_unknown_fields}","text":""},{"location":"attributes/container-attrs/#serdetag-type-tag","title":"<code>#[serde(tag = \"type\")]</code> {#tag}","text":""},{"location":"attributes/container-attrs/#serdetag-t-content-c-tag-content","title":"<code>#[serde(tag = \"t\", content = \"c\")]</code> {#tag--content}","text":""},{"location":"attributes/container-attrs/#serdeuntagged-untagged","title":"<code>#[serde(untagged)]</code> {#untagged}","text":""},{"location":"attributes/container-attrs/#serdebound-t-mytrait-bound","title":"<code>#[serde(bound = \"T: MyTrait\")]</code> {#bound}","text":""},{"location":"attributes/container-attrs/#serdedefault-default","title":"<code>#[serde(default)]</code> {#default}","text":""},{"location":"attributes/container-attrs/#serdedefault-path-default-path","title":"<code>#[serde(default = \"path\")]</code> {#default--path}","text":""},{"location":"attributes/container-attrs/#serderemote-remote","title":"<code>#[serde(remote = \"...\")]</code> {#remote}","text":""},{"location":"attributes/container-attrs/#serdetransparent-transparent","title":"<code>#[serde(transparent)]</code> {#transparent}","text":""},{"location":"attributes/container-attrs/#serdefrom-fromtype-from","title":"<code>#[serde(from = \"FromType\")]</code> {#from}","text":""},{"location":"attributes/container-attrs/#serdetry_from-fromtype-try_from","title":"<code>#[serde(try_from = \"FromType\")]</code> {#try_from}","text":""},{"location":"attributes/container-attrs/#serdeinto-intotype-into","title":"<code>#[serde(into = \"IntoType\")]</code> {#into}","text":""},{"location":"attributes/container-attrs/#serdecrate-crate","title":"<code>#[serde(crate = \"...\")]</code> {#crate}","text":""},{"location":"attributes/field-attrs/","title":"Field attributes","text":"<p>Serialize and deserialize this field with the given name instead of its Rust   name. This is useful for serializing fields as camelCase or   serializing fields with names that are reserved Rust keywords.</p> <p>Allows specifying independent names for serialization vs deserialization:</p> <ul> <li><code>#[serde(rename(serialize = \"ser_name\"))]</code></li> <li><code>#[serde(rename(deserialize = \"de_name\"))]</code></li> <li> <p><code>#[serde(rename(serialize = \"ser_name\", deserialize = \"de_name\"))]</code></p> </li> <li> </li> </ul> <p>Deserialize this field from the given name or from its Rust name. May be   repeated to specify multiple possible names for the same field.</p> <ul> <li> </li> </ul> <p>If the value is not present when deserializing, use the <code>Default::default()</code>.</p> <ul> <li> </li> </ul> <p>If the value is not present when deserializing, call a function to get a   default value. The given function must be callable as <code>fn() -&gt; T</code>. For example   <code>default = \"empty_value\"</code> would invoke <code>empty_value()</code> and <code>default =   \"SomeTrait::some_default\"</code> would invoke <code>SomeTrait::some_default()</code>.</p> <ul> <li> </li> </ul> <p>Flatten the contents of this field into the container it is defined in.</p> <p>This removes one level of structure between the serialized representation and   the Rust data structure representation. It can be used for factoring common   keys into a shared structure, or for capturing remaining fields into a map   with arbitrary string keys. The struct flattening page   provides some examples.</p> <p>Note: this attribute is not supported in combination with structs that use   [<code>deny_unknown_fields</code>]. Neither the outer nor inner flattened struct should   use that attribute.</p> <ul> <li> </li> </ul> <p>Skip this field: do not serialize or deserialize it.</p> <p>When deserializing, Serde will use <code>Default::default()</code> or the function   given by <code>default = \"...\"</code> to get a default value for this field.</p> <ul> <li> </li> </ul> <p>Skip this field when serializing, but not when deserializing.</p> <ul> <li> </li> </ul> <p>Skip this field when deserializing, but not when serializing.</p> <p>When deserializing, Serde will use <code>Default::default()</code> or the function   given by <code>default = \"...\"</code> to get a default value for this field.</p> <ul> <li> </li> </ul> <p>Call a function to determine whether to skip serializing this field. The given   function must be callable as <code>fn(&amp;T) -&gt; bool</code>, although it may be generic over   <code>T</code>. For example <code>skip_serializing_if = \"Option::is_none\"</code> would skip an   Option that is None.</p> <ul> <li> </li> </ul> <p>Serialize this field using a function that is different from its   implementation of <code>Serialize</code>. The given function must be callable as   <code>fn&lt;S&gt;(&amp;T, S) -&gt; Result&lt;S::Ok, S::Error&gt; where S: Serializer</code>, although it   may also be generic over <code>T</code>. Fields used with <code>serialize_with</code> are not   required to implement <code>Serialize</code>.</p> <ul> <li> </li> </ul> <p>Deserialize this field using a function that is different from its   implementation of <code>Deserialize</code>. The given function must be callable as   <code>fn&lt;'de, D&gt;(D) -&gt; Result&lt;T, D::Error&gt; where D: Deserializer&lt;'de&gt;</code>, although it   may also be generic over <code>T</code>. Fields used with <code>deserialize_with</code> are not   required to implement <code>Deserialize</code>.</p> <ul> <li> </li> </ul> <p>Combination of <code>serialize_with</code> and <code>deserialize_with</code>. Serde will use   <code>$module::serialize</code> as the <code>serialize_with</code> function and   <code>$module::deserialize</code> as the <code>deserialize_with</code> function.</p> <ul> <li> </li> </ul> <p>Borrow data for this field from the deserializer by using zero-copy   deserialization. See this example.</p> <ul> <li> </li> </ul> <p>Where-clause for the <code>Serialize</code> and <code>Deserialize</code> impls. This replaces any   trait bounds inferred by Serde for the current field.</p> <p>Allows specifying independent bounds for serialization vs deserialization:</p> <ul> <li><code>#[serde(bound(serialize = \"T: MySerTrait\"))]</code></li> <li><code>#[serde(bound(deserialize = \"T: MyDeTrait\"))]</code></li> <li> <p><code>#[serde(bound(serialize = \"T: MySerTrait\", deserialize = \"T: MyDeTrait\"))]</code></p> </li> <li> </li> </ul> <p>This is used when deriving <code>Serialize</code> for a remote type   that has one or more private fields.</p>"},{"location":"attributes/field-attrs/#serderename-name-rename","title":"<code>#[serde(rename = \"name\")]</code> {#rename}","text":""},{"location":"attributes/field-attrs/#serdealias-name-alias","title":"<code>#[serde(alias = \"name\")]</code> {#alias}","text":""},{"location":"attributes/field-attrs/#serdedefault-default","title":"<code>#[serde(default)]</code> {#default}","text":""},{"location":"attributes/field-attrs/#serdedefault-path-default-path","title":"<code>#[serde(default = \"path\")]</code> {#default--path}","text":""},{"location":"attributes/field-attrs/#serdeflatten-flatten","title":"<code>#[serde(flatten)]</code> {#flatten}","text":""},{"location":"attributes/field-attrs/#serdeskip-skip","title":"<code>#[serde(skip)]</code> {#skip}","text":""},{"location":"attributes/field-attrs/#serdeskip_serializing-skip_serializing","title":"<code>#[serde(skip_serializing)]</code> {#skip_serializing}","text":""},{"location":"attributes/field-attrs/#serdeskip_deserializing-skip_deserializing","title":"<code>#[serde(skip_deserializing)]</code> {#skip_deserializing}","text":""},{"location":"attributes/field-attrs/#serdeskip_serializing_if-path-skip_serializing_if","title":"<code>#[serde(skip_serializing_if = \"path\")]</code> {#skip_serializing_if}","text":""},{"location":"attributes/field-attrs/#serdeserialize_with-path-serialize_with","title":"<code>#[serde(serialize_with = \"path\")]</code> {#serialize_with}","text":""},{"location":"attributes/field-attrs/#serdedeserialize_with-path-deserialize_with","title":"<code>#[serde(deserialize_with = \"path\")]</code> {#deserialize_with}","text":""},{"location":"attributes/field-attrs/#serdewith-module-with","title":"<code>#[serde(with = \"module\")]</code> {#with}","text":""},{"location":"attributes/field-attrs/#serdeborrow-and-serdeborrow-a-b-borrow","title":"<code>#[serde(borrow)]</code> and <code>#[serde(borrow = \"'a + 'b + ...\")]</code> {#borrow}","text":""},{"location":"attributes/field-attrs/#serdebound-t-mytrait-bound","title":"<code>#[serde(bound = \"T: MyTrait\")]</code> {#bound}","text":""},{"location":"attributes/field-attrs/#serdegetter-getter","title":"<code>#[serde(getter = \"...\")]</code> {#getter}","text":""},{"location":"attributes/variant-attrs/","title":"Variant attributes","text":"<p>Serialize and deserialize this variant with the given name instead of its Rust   name.</p> <p>Allows specifying independent names for serialization vs deserialization:</p> <ul> <li><code>#[serde(rename(serialize = \"ser_name\"))]</code></li> <li><code>#[serde(rename(deserialize = \"de_name\"))]</code></li> <li> <p><code>#[serde(rename(serialize = \"ser_name\", deserialize = \"de_name\"))]</code></p> </li> <li> </li> </ul> <p>Deserialize this variant from the given name or from its Rust name. May be   repeated to specify multiple possible names for the same variant.</p> <ul> <li> </li> </ul> <p>Rename all the fields of this struct variant according to the given case   convention. The possible values are <code>\"lowercase\"</code>, <code>\"UPPERCASE\"</code>,   <code>\"PascalCase\"</code>, <code>\"camelCase\"</code>, <code>\"snake_case\"</code>, <code>\"SCREAMING_SNAKE_CASE\"</code>,   <code>\"kebab-case\"</code>, <code>\"SCREAMING-KEBAB-CASE\"</code>.</p> <p>Allows specifying independent cases for serialization vs deserialization:</p> <ul> <li><code>#[serde(rename_all(serialize = \"...\"))]</code></li> <li><code>#[serde(rename_all(deserialize = \"...\"))]</code></li> <li> <p><code>#[serde(rename_all(serialize = \"...\", deserialize = \"...\"))]</code></p> </li> <li> </li> </ul> <p>Never serialize or deserialize this variant.</p> <ul> <li> </li> </ul> <p>Never serialize this variant. Trying to serialize this variant is treated as   an error.</p> <ul> <li> </li> </ul> <p>Never deserialize this variant.</p> <ul> <li> </li> </ul> <p>Serialize this variant using a function that is different from its   implementation of <code>Serialize</code>. The given function must be callable as   <code>fn&lt;S&gt;(&amp;FIELD0, &amp;FIELD1, ..., S) -&gt; Result&lt;S::Ok, S::Error&gt; where S:   Serializer</code>, although it may also be generic over the <code>FIELD{n}</code> types.   Variants used with <code>serialize_with</code> are not required to be able to derive   <code>Serialize</code>.</p> <p><code>FIELD{n}</code> exists for every field of the variant. So a unit variant has just   the <code>S</code> argument, and tuple/struct variants have an argument for every field.</p> <ul> <li> </li> </ul> <p>Deserialize this variant using a function that is different from its   implementation of <code>Deserialize</code>. The given function must be callable as   <code>fn&lt;'de, D&gt;(D) -&gt; Result&lt;FIELDS, D::Error&gt; where D: Deserializer&lt;'de&gt;</code>,   although it may also be generic over the elements of <code>FIELDS</code>. Variants used   with <code>deserialize_with</code> are not required be able to derive <code>Deserialize</code>.</p> <p><code>FIELDS</code> is a tuple of all fields of the variant. A unit variant will have   <code>()</code> as its <code>FIELDS</code> type.</p> <ul> <li> </li> </ul> <p>Combination of <code>serialize_with</code> and <code>deserialize_with</code>. Serde will use   <code>$module::serialize</code> as the <code>serialize_with</code> function and   <code>$module::deserialize</code> as the <code>deserialize_with</code> function.</p> <ul> <li> </li> </ul> <p>Where-clause for the <code>Serialize</code> and/or <code>Deserialize</code> impls. This replaces any   trait bounds inferred by Serde for the current variant.</p> <p>Allows specifying independent bounds for serialization vs deserialization:</p> <ul> <li><code>#[serde(bound(serialize = \"T: MySerTrait\"))]</code></li> <li><code>#[serde(bound(deserialize = \"T: MyDeTrait\"))]</code></li> <li> <p><code>#[serde(bound(serialize = \"T: MySerTrait\", deserialize = \"T: MyDeTrait\"))]</code></p> </li> <li> </li> </ul> <p>Borrow data for this field from the deserializer by using zero-copy   deserialization. See this example.   Only allowed on a newtype variant (a tuple variant with only one field).</p> <ul> <li> </li> </ul> <p>Deserialize this variant if the enum tag is anything other than the tag of one   of the other variants in this enum. Only allowed on a unit variant inside of   an internally tagged or adjacently tagged enum.</p> <p>For example if we have an internally tagged enum with <code>serde(tag = \"variant\")</code>   containing variants <code>A</code>, <code>B</code>, and <code>Unknown</code> marked <code>serde(other)</code>, the   <code>Unknown</code> variant would be deserialized any time the <code>\"variant\"</code> field of the   input is neither <code>\"A\"</code> nor <code>\"B\"</code>.</p>"},{"location":"attributes/variant-attrs/#serderename-name-rename","title":"<code>#[serde(rename = \"name\")]</code> {#rename}","text":""},{"location":"attributes/variant-attrs/#serdealias-name-alias","title":"<code>#[serde(alias = \"name\")]</code> {#alias}","text":""},{"location":"attributes/variant-attrs/#serderename_all-rename_all","title":"<code>#[serde(rename_all = \"...\")]</code> {#rename_all}","text":""},{"location":"attributes/variant-attrs/#serdeskip-skip","title":"<code>#[serde(skip)]</code> {#skip}","text":""},{"location":"attributes/variant-attrs/#serdeskip_serializing-skip_serializing","title":"<code>#[serde(skip_serializing)]</code> {#skip_serializing}","text":""},{"location":"attributes/variant-attrs/#serdeskip_deserializing-skip_deserializing","title":"<code>#[serde(skip_deserializing)]</code> {#skip_deserializing}","text":""},{"location":"attributes/variant-attrs/#serdeserialize_with-path-serialize_with","title":"<code>#[serde(serialize_with = \"path\")]</code> {#serialize_with}","text":""},{"location":"attributes/variant-attrs/#serdedeserialize_with-path-deserialize_with","title":"<code>#[serde(deserialize_with = \"path\")]</code> {#deserialize_with}","text":""},{"location":"attributes/variant-attrs/#serdewith-module-with","title":"<code>#[serde(with = \"module\")]</code> {#with}","text":""},{"location":"attributes/variant-attrs/#serdebound-t-mytrait-bound","title":"<code>#[serde(bound = \"T: MyTrait\")]</code> {#bound}","text":""},{"location":"attributes/variant-attrs/#serdeborrow-and-serdeborrow-a-b-borrow","title":"<code>#[serde(borrow)]</code> and <code>#[serde(borrow = \"'a + 'b + ...\")]</code> {#borrow}","text":""},{"location":"attributes/variant-attrs/#serdeother-other","title":"<code>#[serde(other)]</code> {#other}","text":""},{"location":"custom-serialization/","title":"Custom serialization","text":"<p>Serde's derive macro through <code>#[derive(Serialize, Deserialize)]</code> provides reasonable default serialization behavior for structs and enums and it can be customized to some extent using attributes. For unusual needs, Serde allows full customization of the serialization behavior by manually implementing [<code>Serialize</code>] and [<code>Deserialize</code>] traits for your type.</p> <p>The traits each have a single method:</p> <pre><code># use serde::{Serializer, Deserializer};\n#\npub trait Serialize {\nfn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;\nwhere\nS: Serializer;\n}\npub trait Deserialize&lt;'de&gt;: Sized {\nfn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Self, D::Error&gt;\nwhere\nD: Deserializer&lt;'de&gt;;\n}\n#\n# fn main() {}\n</code></pre> <p>These methods are generic over the serialization format, represented by the [<code>Serializer</code>] and [<code>Deserializer</code>] traits. For example there is one Serializer type for JSON and a different one for Postcard.</p> <ul> <li>Implementing <code>Serialize</code></li> <li>Implementing <code>Deserialize</code></li> </ul>"},{"location":"custom-serialization/impl-deserialize/","title":"Implementing Deserialize","text":"<p>The [<code>Deserialize</code>] trait looks like this:</p> <pre><code># use serde::Deserializer;\n#\npub trait Deserialize&lt;'de&gt;: Sized {\nfn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Self, D::Error&gt;\nwhere\nD: Deserializer&lt;'de&gt;;\n}\n#\n# fn main() {}\n</code></pre> <p>This method's job is to map the type into the Serde data model by providing the [<code>Deserializer</code>] with a [<code>Visitor</code>] that can be driven by the <code>Deserializer</code> to construct an instance of your type.</p> <p>In most cases Serde's derive is able to generate an appropriate implementation of <code>Deserialize</code> for structs and enums defined in your crate. Should you need to customize the deserialization behavior for a type in a way that derive does not support, you can implement <code>Deserialize</code> yourself. Implementing <code>Deserialize</code> for a type tends to be more complicated than implementing <code>Serialize</code>.</p> <p>The <code>Deserializer</code> trait supports two entry point styles which enables different kinds of deserialization.</p> <ol> <li> <p>The <code>deserialize_any</code> method. Self-describing data formats like JSON are able    to look at the serialized data and tell what it represents. For example the    JSON deserializer may see an opening curly brace (<code>{</code>) and know that it is    seeing a map. If the data format supports <code>Deserializer::deserialize_any</code>, it    will drive the Visitor using whatever type it sees in the input. JSON uses    this approach when deserializing <code>serde_json::Value</code> which is an enum that    can represent any JSON document. Without knowing what is in a JSON document,    we can deserialize it to <code>serde_json::Value</code> by going through    <code>Deserializer::deserialize_any</code>.</p> </li> <li> <p>The various other <code>deserialize_*</code> methods. Non-self-describing formats like    Postcard need to be told what is in the input in order to deserialize it. The    <code>deserialize_*</code> methods are hints to the deserializer for how to interpret    the next piece of input. Non-self-describing formats are not able to    deserialize something like <code>serde_json::Value</code> which relies on    <code>Deserializer::deserialize_any</code>.</p> </li> </ol> <p>When implementing <code>Deserialize</code>, you should avoid relying on <code>Deserializer::deserialize_any</code> unless you need to be told by the Deserializer what type is in the input. Know that relying on <code>Deserializer::deserialize_any</code> means your data type will be able to deserialize from self-describing formats only, ruling out Postcard and many others.</p>"},{"location":"custom-serialization/impl-deserialize/#the-visitor-trait","title":"The Visitor trait","text":"<p>A [<code>Visitor</code>] is instantiated by a <code>Deserialize</code> impl and passed to a <code>Deserializer</code>. The <code>Deserializer</code> then calls a method on the <code>Visitor</code> in order to construct the desired type.</p> <p>Here is a <code>Visitor</code> that is able to deserialize a primitive <code>i32</code> from a variety of types.</p> <pre><code>use std::fmt;\nuse serde::de::{self, Visitor};\n# #[allow(dead_code)]\nstruct I32Visitor;\nimpl&lt;'de&gt; Visitor&lt;'de&gt; for I32Visitor {\ntype Value = i32;\nfn expecting(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {\nformatter.write_str(\"an integer between -2^31 and 2^31\")\n}\nfn visit_i8&lt;E&gt;(self, value: i8) -&gt; Result&lt;Self::Value, E&gt;\nwhere\nE: de::Error,\n{\nOk(i32::from(value))\n}\nfn visit_i32&lt;E&gt;(self, value: i32) -&gt; Result&lt;Self::Value, E&gt;\nwhere\nE: de::Error,\n{\nOk(value)\n}\nfn visit_i64&lt;E&gt;(self, value: i64) -&gt; Result&lt;Self::Value, E&gt;\nwhere\nE: de::Error,\n{\nuse std::i32;\nif value &gt;= i64::from(i32::MIN) &amp;&amp; value &lt;= i64::from(i32::MAX) {\nOk(value as i32)\n} else {\nErr(E::custom(format!(\"i32 out of range: {}\", value)))\n}\n}\n// Similar for other methods:\n//   - visit_i16\n//   - visit_u8\n//   - visit_u16\n//   - visit_u32\n//   - visit_u64\n}\n#\n# fn main() {}\n</code></pre> <p>The <code>Visitor</code> trait has lots more methods that are not implemented for <code>I32Visitor</code>. Leaving them unimplemented means a type error is returned if they get called. For example <code>I32Visitor</code> does not implement <code>Visitor::visit_map</code>, so trying to deserialize an i32 when the input contains a map is a type error.</p>"},{"location":"custom-serialization/impl-deserialize/#driving-a-visitor","title":"Driving a Visitor","text":"<p>Deserialize a value by passing a <code>Visitor</code> to the given <code>Deserializer</code>. The <code>Deserializer</code> will call one of the <code>Visitor</code> methods depending on the input data, which is known as \"driving\" the <code>Visitor</code>.</p> <pre><code># use std::fmt;\n#\n# use serde::de::{Deserialize, Deserializer, Visitor};\n#\n# #[allow(non_camel_case_types)]\n# struct i32;\n# struct I32Visitor;\n#\n# impl&lt;'de&gt; Visitor&lt;'de&gt; for I32Visitor {\n#     type Value = i32;\n#\n#     fn expecting(&amp;self, _: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n#         unimplemented!()\n#     }\n# }\n#\nimpl&lt;'de&gt; Deserialize&lt;'de&gt; for i32 {\nfn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;i32, D::Error&gt;\nwhere\nD: Deserializer&lt;'de&gt;,\n{\ndeserializer.deserialize_i32(I32Visitor)\n}\n}\n#\n# fn main() {}\n</code></pre> <p>Note that a <code>Deserializer</code> will not necessarily follow the type hint, so the call to <code>deserialize_i32</code> does not necessarily mean the <code>Deserializer</code> will call <code>I32Visitor::visit_i32</code>. For example JSON treats all signed integer types alike. The JSON <code>Deserializer</code> will call <code>visit_i64</code> for any signed integer and <code>visit_u64</code> for any unsigned integer, even if hinted a different type.</p>"},{"location":"custom-serialization/impl-deserialize/#other-examples","title":"Other examples","text":"<ul> <li>Deserializing a map</li> <li>Deserializing a struct</li> </ul>"},{"location":"custom-serialization/impl-serialize/","title":"Implementing Serialize","text":"<p>The [<code>Serialize</code>] trait looks like this:</p> <pre><code># use serde::Serializer;\n#\npub trait Serialize {\nfn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;\nwhere\nS: Serializer;\n}\n#\n# fn main() {}\n</code></pre> <p>This method's job is to take your type (<code>&amp;self</code>) and map it into the Serde data model by invoking exactly one of the methods on the given [<code>Serializer</code>].</p> <p>In most cases Serde's derive is able to generate an appropriate implementation of <code>Serialize</code> for structs and enums defined in your crate. Should you need to customize the serialization behavior for a type in a way that derive does not support, you can implement <code>Serialize</code> yourself.</p>"},{"location":"custom-serialization/impl-serialize/#serializing-a-primitive","title":"Serializing a primitive","text":"<p>As the simplest example, here is the builtin <code>Serialize</code> impl for the primitive <code>i32</code>.</p> <pre><code># use std::os::raw::c_int as ActualI32;\n#\n# use serde::{Serialize, Serializer};\n#\n# #[allow(dead_code, non_camel_case_types)]\n# struct i32;\n#\n# trait Serialize2 {\n#     fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;\n#     where\n#         S: Serializer;\n# }\n#\nimpl Serialize for i32 {\nfn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;\nwhere\nS: Serializer,\n{\n#         impl Serialize2 for ActualI32 {\n#             fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;\n#             where\n#                 S: Serializer,\n#             {\nserializer.serialize_i32(*self)\n#             }\n#         }\n#\n#         _ = serializer;\n#         unimplemented!()\n}\n}\n#\n# fn main() {}\n</code></pre> <p>Serde provides such impls for all of Rust's primitive types so you are not responsible for implementing them yourself, but <code>serialize_i32</code> and similar methods may be useful if you have a type that needs to be represented as a primitive in its serialized form. For example you could serialize a C-like enum as a primitive number.</p>"},{"location":"custom-serialization/impl-serialize/#serializing-a-sequence-or-map","title":"Serializing a sequence or map","text":"<p>Compound types follow a three-step process of init, elements, end.</p> <pre><code># use std::marker::PhantomData;\n#\n# struct Vec&lt;T&gt;(PhantomData&lt;T&gt;);\n#\n# impl&lt;T&gt; Vec&lt;T&gt; {\n#     fn len(&amp;self) -&gt; usize {\n#         unimplemented!()\n#     }\n# }\n#\n# impl&lt;'a, T&gt; IntoIterator for &amp;'a Vec&lt;T&gt; {\n#     type Item = &amp;'a T;\n#     type IntoIter = Box&lt;dyn Iterator&lt;Item = &amp;'a T&gt;&gt;;\n#\n#     fn into_iter(self) -&gt; Self::IntoIter {\n#         unimplemented!()\n#     }\n# }\n#\n# struct MyMap&lt;K, V&gt;(PhantomData&lt;K&gt;, PhantomData&lt;V&gt;);\n#\n# impl&lt;K, V&gt; MyMap&lt;K, V&gt; {\n#     fn len(&amp;self) -&gt; usize {\n#         unimplemented!()\n#     }\n# }\n#\n# impl&lt;'a, K, V&gt; IntoIterator for &amp;'a MyMap&lt;K, V&gt; {\n#     type Item = (&amp;'a K, &amp;'a V);\n#     type IntoIter = Box&lt;dyn Iterator&lt;Item = (&amp;'a K, &amp;'a V)&gt;&gt;;\n#\n#     fn into_iter(self) -&gt; Self::IntoIter {\n#         unimplemented!()\n#     }\n# }\n#\nuse serde::ser::{Serialize, Serializer, SerializeSeq, SerializeMap};\nimpl&lt;T&gt; Serialize for Vec&lt;T&gt;\nwhere\nT: Serialize,\n{\nfn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;\nwhere\nS: Serializer,\n{\nlet mut seq = serializer.serialize_seq(Some(self.len()))?;\nfor e in self {\nseq.serialize_element(e)?;\n}\nseq.end()\n}\n}\nimpl&lt;K, V&gt; Serialize for MyMap&lt;K, V&gt;\nwhere\nK: Serialize,\nV: Serialize,\n{\nfn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;\nwhere\nS: Serializer,\n{\nlet mut map = serializer.serialize_map(Some(self.len()))?;\nfor (k, v) in self {\nmap.serialize_entry(k, v)?;\n}\nmap.end()\n}\n}\n#\n# fn main() {}\n</code></pre>"},{"location":"custom-serialization/impl-serialize/#serializing-a-tuple","title":"Serializing a tuple","text":"<p>The <code>serialize_tuple</code> method is a lot like <code>serialize_seq</code>. The distinction Serde makes is that <code>serialize_tuple</code> is for sequences where the length does not need to be serialized because it will be known at deserialization time. The usual examples are Rust tuples and arrays. In non-self-describing formats a <code>Vec&lt;T&gt;</code> needs to be serialized with its length in order to be able to deserialize a <code>Vec&lt;T&gt;</code> back out. But a <code>[T; 16]</code> can be serialized using <code>serialize_tuple</code> because the length will be known at deserialization time without looking at the serialized bytes.</p>"},{"location":"custom-serialization/impl-serialize/#serializing-a-struct","title":"Serializing a struct","text":"<p>Serde distinguishes between four types of structs. Ordinary structs and tuple structs follow the three-step process of init, elements, end just like a sequence or map. Newtype structs and unit structs are more like primitives.</p> <pre><code># #![allow(dead_code)]\n#\n// An ordinary struct. Use three-step process:\n//   1. serialize_struct\n//   2. serialize_field\n//   3. end\nstruct Color {\nr: u8,\ng: u8,\nb: u8,\n}\n// A tuple struct. Use three-step process:\n//   1. serialize_tuple_struct\n//   2. serialize_field\n//   3. end\nstruct Point2D(f64, f64);\n// A newtype struct. Use serialize_newtype_struct.\nstruct Inches(u64);\n// A unit struct. Use serialize_unit_struct.\nstruct Instance;\n#\n# fn main() {}\n</code></pre> <p>Structs and maps may look similar in some formats, including JSON. The distinction Serde makes is that structs have keys that are compile-time constant strings and will be known at deserialization time without looking at the serialized data. This condition enables some data formats to handle structs much more efficiently and compactly than maps.</p> <p>Data formats are encouraged to treat newtype structs as insignificant wrappers around the inner value, serializing just the inner value. See for example JSON's treatment of newtype structs.</p> <pre><code># #![allow(dead_code)]\n#\nuse serde::ser::{Serialize, Serializer, SerializeStruct};\nstruct Color {\nr: u8,\ng: u8,\nb: u8,\n}\nimpl Serialize for Color {\nfn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;\nwhere\nS: Serializer,\n{\n// 3 is the number of fields in the struct.\nlet mut state = serializer.serialize_struct(\"Color\", 3)?;\nstate.serialize_field(\"r\", &amp;self.r)?;\nstate.serialize_field(\"g\", &amp;self.g)?;\nstate.serialize_field(\"b\", &amp;self.b)?;\nstate.end()\n}\n}\n#\n# fn main() {}\n</code></pre>"},{"location":"custom-serialization/impl-serialize/#serializing-an-enum","title":"Serializing an enum","text":"<p>Serializing enum variants is very similar to serializing structs.</p> <pre><code># #[allow(dead_code)]\nenum E {\n// Use three-step process:\n//   1. serialize_struct_variant\n//   2. serialize_field\n//   3. end\nColor { r: u8, g: u8, b: u8 },\n// Use three-step process:\n//   1. serialize_tuple_variant\n//   2. serialize_field\n//   3. end\nPoint2D(f64, f64),\n// Use serialize_newtype_variant.\nInches(u64),\n// Use serialize_unit_variant.\nInstance,\n}\n#\n# fn main() {}\n</code></pre>"},{"location":"custom-serialization/impl-serialize/#other-special-cases","title":"Other special cases","text":"<p>There are two more special cases that are part of the Serializer trait.</p> <p>There is a method <code>serialize_bytes</code> which serializes a <code>&amp;[u8]</code>. Some formats treat bytes like any other seq, but some formats are able to serialize bytes more compactly. Currently Serde does not use <code>serialize_bytes</code> in the <code>Serialize</code> impl for <code>&amp;[u8]</code> or <code>Vec&lt;u8&gt;</code> but once specialization lands in stable Rust we will begin using it. For now the [<code>serde_bytes</code>] crate can be used to enable efficient handling of <code>&amp;[u8]</code> and <code>Vec&lt;u8&gt;</code> through <code>serialize_bytes</code>.</p> <p>Finally, <code>serialize_some</code> and <code>serialize_none</code> correspond to <code>Option::Some</code> and <code>Option::None</code>. Users tend to have different expectations around the <code>Option</code> enum compared to other enums. Serde JSON will serialize <code>Option::None</code> as <code>null</code> and <code>Option::Some</code> as just the contained value.</p>"},{"location":"custom-serialization/unit-testing/","title":"Unit testing","text":"<p>The <code>serde_test</code> crate provides a convenient concise way to write unit tests for implementations of <code>Serialize</code> and <code>Deserialize</code>.</p> <p>The <code>Serialize</code> impl for a value can be characterized by the sequence of <code>Serializer</code> calls that are made in the course of serializing the value, so <code>serde_test</code> provides a <code>Token</code> abstraction which corresponds roughly to <code>Serializer</code> method calls. It provides an <code>assert_ser_tokens</code> function to test that a value serializes into a particular sequence of method calls, an <code>assert_de_tokens</code> function to test that a value can be deserialized from a particular sequence of method calls, and an <code>assert_tokens</code> function to test both directions. It also provides functions to test expected failure conditions.</p> <p>Here is an example from the <code>linked-hash-map</code> crate.</p> <pre><code># #[allow(unused_imports)]\nuse linked_hash_map::LinkedHashMap;\n#\n# mod test {\n#     use std::fmt;\n#     use std::marker::PhantomData;\n#\n#     use serde::ser::{Serialize, Serializer, SerializeMap};\n#     use serde::de::{Deserialize, Deserializer, Visitor, MapAccess};\n#\nuse serde_test::{Token, assert_tokens};\n#\n#     // The version of linked-hash-map used by yaml-rust is not compatible\n#     // with Serde 0.9, and Skeptic tests cannot have more than one version\n#     // of any dependency. Reimplement a dumb immitation here.\n#     #[derive(PartialEq, Debug)]\n#     struct LinkedHashMap&lt;K, V&gt;(Vec&lt;(K, V)&gt;);\n#\n#     impl&lt;K, V&gt; LinkedHashMap&lt;K, V&gt; {\n#         fn new() -&gt; Self {\n#             LinkedHashMap(Vec::new())\n#         }\n#\n#         fn insert(&amp;mut self, k: K, v: V) {\n#             self.0.push((k, v));\n#         }\n#     }\n#\n#     impl&lt;K, V&gt; Serialize for LinkedHashMap&lt;K, V&gt;\n#     where\n#         K: Serialize,\n#         V: Serialize,\n#     {\n#         fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;\n#         where\n#             S: Serializer,\n#         {\n#             let mut map = serializer.serialize_map(Some(self.0.len()))?;\n#             for &amp;(ref k, ref v) in &amp;self.0 {\n#                 map.serialize_entry(k, v)?;\n#             }\n#             map.end()\n#         }\n#     }\n#\n#     struct LinkedHashMapVisitor&lt;K, V&gt;(PhantomData&lt;fn() -&gt; LinkedHashMap&lt;K, V&gt;&gt;);\n#\n#     impl&lt;'de, K, V&gt; Visitor&lt;'de&gt; for LinkedHashMapVisitor&lt;K, V&gt;\n#     where\n#         K: Deserialize&lt;'de&gt;,\n#         V: Deserialize&lt;'de&gt;,\n#     {\n#         type Value = LinkedHashMap&lt;K, V&gt;;\n#\n#         fn expecting(&amp;self, _: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n#             unimplemented!()\n#         }\n#\n#         fn visit_map&lt;M&gt;(self, mut access: M) -&gt; Result&lt;Self::Value, M::Error&gt;\n#         where\n#             M: MapAccess&lt;'de&gt;,\n#         {\n#             let mut map = LinkedHashMap::new();\n#             while let Some((key, value)) = access.next_entry()? {\n#                 map.insert(key, value);\n#             }\n#             Ok(map)\n#         }\n#     }\n#\n#     impl&lt;'de, K, V&gt; Deserialize&lt;'de&gt; for LinkedHashMap&lt;K, V&gt;\n#     where\n#         K: Deserialize&lt;'de&gt;,\n#         V: Deserialize&lt;'de&gt;,\n#     {\n#         fn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Self, D::Error&gt;\n#         where\n#             D: Deserializer&lt;'de&gt;,\n#         {\n#             deserializer.deserialize_map(LinkedHashMapVisitor(PhantomData))\n#         }\n#     }\n#[test]\n# fn skeptic_test_ser_de_empty() {}\nfn test_ser_de_empty() {\nlet map = LinkedHashMap::&lt;char, u32&gt;::new();\nassert_tokens(&amp;map, &amp;[\nToken::Map { len: Some(0) },\nToken::MapEnd,\n]);\n}\n#[test]\n# fn skeptic_test_ser_de() {}\nfn test_ser_de() {\nlet mut map = LinkedHashMap::new();\nmap.insert('b', 20);\nmap.insert('a', 10);\nmap.insert('c', 30);\nassert_tokens(&amp;map, &amp;[\nToken::Map { len: Some(3) },\nToken::Char('b'),\nToken::I32(20),\nToken::Char('a'),\nToken::I32(10),\nToken::Char('c'),\nToken::I32(30),\nToken::MapEnd,\n]);\n}\n#\n#     pub fn run_tests() {\n#         test_ser_de_empty();\n#         test_ser_de();\n#     }\n# }\n#\n# fn main() {\n#     test::run_tests();\n# }\n</code></pre>"},{"location":"data-format/","title":"Writing a data format","text":"<p>The most important thing to understand before writing a data format is that Serde is not a parsing library. Nothing in Serde is going to help you parse whatever format you are implementing. The role of Serde is very specific:</p> <ul> <li>Serialization \u2014 taking arbitrary data structures from the user and   rendering them in the format with maximum efficiency.</li> <li>Deserialization \u2014 interpreting the data that you parse into data   structures of the user's choice with maximum efficiency.</li> </ul> <p>Parsing is neither of these things and you will either be writing parsing code from scratch or using a parsing library to implement your Deserializer.</p> <p>The second most important thing to understand is the Serde data model.</p> <p>The following pages walk through a basic but functional JSON serializer and deserializer implemented using Serde.</p> <ul> <li>Conventions for what to export at the root of the crate</li> <li>Serde error traits and error handling</li> <li>Implementing a Serializer</li> <li>Implementing a Deserializer</li> </ul> <p>You can find these four source files all together as a buildable crate in this GitHub repository.</p>"},{"location":"data-format/conventions/","title":"Conventions","text":"<p>By convention a Serde data format crate provides the following in the root module or re-exported from the root module:</p> <ul> <li>An Error type common to both serialization and deserialization.</li> <li>A Result typedef which is equivalent to std::result::Result&lt;T, Error&gt;.</li> <li>A Serializer type which implements serde::Serializer.</li> <li>A Deserializer type which implements serde::Deserializer.</li> <li>One or more to_abc functions depending on what types the format supports     serializing to. For example to_string which returns a String, to_bytes which     returns a Vec&lt;u8&gt;, or to_writer which writes into an [<code>io::Write</code>].</li> <li>One or more from_xyz functions depending on what types the format supports     deserializing from. For example from_str which takes a &amp;str, from_bytes     which takes a &amp;[u8], or from_reader which takes an [<code>io::Read</code>].</li> </ul> <p>In addition, formats that provide serialization-specific or deserialization-specific APIs beyond Serializer and Deserializer should expose those under top-level <code>ser</code> and <code>de</code> modules. For example serde_json provides a pluggable pretty-printer trait as [<code>serde_json::ser::Formatter</code>].</p> <p>A basic data format begins like this. The three modules are discussed in more detail on the following pages.</p> <p>!FILENAME src/lib.rs <pre><code># macro_rules! modules {\n#     (mod de) =&gt; {\n#         mod de {\n#             pub fn from_str() {}\n#             pub type Deserializer = ();\n#         }\n#     };\n#     (mod error) =&gt; {\n#         mod error {\n#             pub type Error = ();\n#             pub type Result = ();\n#         }\n#     };\n#     (mod ser) =&gt; {\n#         mod ser {\n#             pub fn to_string() {}\n#             pub type Serializer = ();\n#         }\n#     };\n#     ($(mod $n:ident;)+) =&gt; {\n#         $(\n#             modules!(mod $n);\n#         )+\n#     };\n# }\n#\n# modules! {\nmod de;\nmod error;\nmod ser;\n# }\npub use de::{from_str, Deserializer};\npub use error::{Error, Result};\npub use ser::{to_string, Serializer};\n#\n# fn main() {}\n</code></pre></p>"},{"location":"data-format/error-handling/","title":"Error handling","text":"<p>During serialization, the [<code>Serialize</code>] trait maps a Rust data structure into Serde's data model and the [<code>Serializer</code>] trait maps the data model into the output format. During deserialization, the [<code>Deserializer</code>] maps the input data into Serde's data model and the [<code>Deserialize</code>] and [<code>Visitor</code>] traits map the data model into the resulting data structure. Any of these steps can fail.</p> <ul> <li><code>Serialize</code> can fail, for example when a <code>Mutex&lt;T&gt;</code> is being serialized and   the mutex happens to be poisoned.</li> <li><code>Serializer</code> can fail, for example the Serde data model allows maps with   non-string keys but JSON does not.</li> <li><code>Deserializer</code> can fail, especially if the input data is syntactically   invalid.</li> <li><code>Deserialize</code> can fail, usually because the input is the wrong type for the   value it is being deserialized into.</li> </ul> <p>In Serde, errors from the <code>Serializer</code> and <code>Deserializer</code> work just like they would in any other Rust library. The crate defines an error type, public functions return a Result with that error type, and there are variants for the various possible failure modes.</p> <p>Handling of errors from the <code>Serialize</code> and <code>Deserialize</code>, the data structure being processed by the library, is built around the [<code>ser::Error</code>] and [<code>de::Error</code>] traits. These traits allow the data format to expose constructors for its error type for the data structure to use in various situations.</p> <p>!FILENAME src/error.rs <pre><code># macro_rules! ignore {\n#     ($($tt:tt)*) =&gt; {}\n# }\n#\n# ignore! {\nuse std;\n# }\nuse std::fmt::{self, Display};\nuse serde::{de, ser};\npub type Result&lt;T&gt; = std::result::Result&lt;T, Error&gt;;\n// This is a bare-bones implementation. A real library would provide additional\n// information in its error type, for example the line and column at which the\n// error occurred, the byte offset into the input, or the current key being\n// processed.\n#[derive(Debug)]\npub enum Error {\n// One or more variants that can be created by data structures through the\n// `ser::Error` and `de::Error` traits. For example the Serialize impl for\n// Mutex&lt;T&gt; might return an error because the mutex is poisoned, or the\n// Deserialize impl for a struct may return an error because a required\n// field is missing.\nMessage(String),\n// Zero or more variants that can be created directly by the Serializer and\n// Deserializer without going through `ser::Error` and `de::Error`. These\n// are specific to the format, in this case JSON.\nEof,\nSyntax,\nExpectedBoolean,\nExpectedInteger,\nExpectedString,\nExpectedNull,\nExpectedArray,\nExpectedArrayComma,\nExpectedArrayEnd,\nExpectedMap,\nExpectedMapColon,\nExpectedMapComma,\nExpectedMapEnd,\nExpectedEnum,\nTrailingCharacters,\n}\nimpl ser::Error for Error {\nfn custom&lt;T: Display&gt;(msg: T) -&gt; Self {\nError::Message(msg.to_string())\n}\n}\nimpl de::Error for Error {\nfn custom&lt;T: Display&gt;(msg: T) -&gt; Self {\nError::Message(msg.to_string())\n}\n}\nimpl Display for Error {\nfn fmt(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {\nmatch self {\nError::Message(msg) =&gt; formatter.write_str(msg),\nError::Eof =&gt; formatter.write_str(\"unexpected end of input\"),\n/* and so forth */\n#             _ =&gt; unimplemented!(),\n}\n}\n}\nimpl std::error::Error for Error {}\n#\n# fn main() {}\n</code></pre></p>"},{"location":"data-format/impl-deserializer/","title":"Implementing a Deserializer","text":"<p>This page gives a basic but functional implementation of a JSON deserializer using Serde.</p> <p>As with the serializer, the [<code>Deserializer</code>] trait has a lot of methods but none of them are complicated in this implementation. The deserializer is responsible for mapping the input data into Serde's data model by invoking exactly one of the methods on the [<code>Visitor</code>] that it receives.</p> <p>The <code>Deserializer</code> methods are called by a <code>Deserialize</code> impl as a hint to indicate what Serde data model type the <code>Deserialize</code> type expects to see in the input. For self-describing formats like JSON, it is fine for the <code>Deserializer</code> to ignore this hint and just call whichever <code>Visitor</code> method corresponds to the content of the input data. Other formats, especially compact binary formats like Postcard, rely on the hint to determine how the input data is to be interpreted.</p> <p>Self-describing formats can save a lot of code by using the [<code>forward_to_deserialize_any!</code>] macro to ignore hints and forward some or all of the methods of the <code>Deserializer</code> trait to the <code>deserialize_any</code> method.</p> <p>The code below implements every method explicitly for documentation purposes but there is no advantage to that.</p> <p>Deserializer lifetimes have their own dedicated page.</p> <p>!FILENAME src/de.rs <pre><code># mod error {\n#     use std;\n#     use std::fmt::{self, Display};\n#\n#     use serde::{ser, de};\n#\n#     pub type Result&lt;T&gt; = ::std::result::Result&lt;T, Error&gt;;\n#\n#     #[derive(Clone, Debug, PartialEq)]\n#     pub enum Error {\n#         Message(String),\n#         Eof,\n#         Syntax,\n#         ExpectedBoolean,\n#         ExpectedInteger,\n#         ExpectedString,\n#         ExpectedNull,\n#         ExpectedArray,\n#         ExpectedArrayComma,\n#         ExpectedArrayEnd,\n#         ExpectedMap,\n#         ExpectedMapColon,\n#         ExpectedMapComma,\n#         ExpectedMapEnd,\n#         ExpectedEnum,\n#         TrailingCharacters,\n#     }\n#\n#     impl ser::Error for Error {\n#         fn custom&lt;T: Display&gt;(msg: T) -&gt; Self {\n#             Error::Message(msg.to_string())\n#         }\n#     }\n#\n#     impl de::Error for Error {\n#         fn custom&lt;T: Display&gt;(msg: T) -&gt; Self {\n#             Error::Message(msg.to_string())\n#         }\n#     }\n#\n#     impl Display for Error {\n#         fn fmt(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n#             match self {\n#                 Error::Message(msg) =&gt; formatter.write_str(msg),\n#                 Error::Eof =&gt; formatter.write_str(\"unexpected end of input\"),\n#                 /* and so forth */\n#                 _ =&gt; unimplemented!(),\n#             }\n#         }\n#     }\n#\n#     impl std::error::Error for Error {}\n# }\n#\nuse std::ops::{AddAssign, MulAssign, Neg};\nuse serde::Deserialize;\nuse serde::de::{\nself, DeserializeSeed, EnumAccess, IntoDeserializer, MapAccess, SeqAccess,\nVariantAccess, Visitor,\n};\nuse error::{Error, Result};\npub struct Deserializer&lt;'de&gt; {\n// This string starts with the input data and characters are truncated off\n// the beginning as data is parsed.\ninput: &amp;'de str,\n}\nimpl&lt;'de&gt; Deserializer&lt;'de&gt; {\n// By convention, `Deserializer` constructors are named like `from_xyz`.\n// That way basic use cases are satisfied by something like\n// `serde_json::from_str(...)` while advanced use cases that require a\n// deserializer can make one with `serde_json::Deserializer::from_str(...)`.\npub fn from_str(input: &amp;'de str) -&gt; Self {\nDeserializer { input }\n}\n}\n// By convention, the public API of a Serde deserializer is one or more\n// `from_xyz` methods such as `from_str`, `from_bytes`, or `from_reader`\n// depending on what Rust types the deserializer is able to consume as input.\n//\n// This basic deserializer supports only `from_str`.\npub fn from_str&lt;'a, T&gt;(s: &amp;'a str) -&gt; Result&lt;T&gt;\nwhere\nT: Deserialize&lt;'a&gt;,\n{\nlet mut deserializer = Deserializer::from_str(s);\nlet t = T::deserialize(&amp;mut deserializer)?;\nif deserializer.input.is_empty() {\nOk(t)\n} else {\nErr(Error::TrailingCharacters)\n}\n}\n// SERDE IS NOT A PARSING LIBRARY. This impl block defines a few basic parsing\n// functions from scratch. More complicated formats may wish to use a dedicated\n// parsing library to help implement their Serde deserializer.\nimpl&lt;'de&gt; Deserializer&lt;'de&gt; {\n// Look at the first character in the input without consuming it.\nfn peek_char(&amp;mut self) -&gt; Result&lt;char&gt; {\nself.input.chars().next().ok_or(Error::Eof)\n}\n// Consume the first character in the input.\nfn next_char(&amp;mut self) -&gt; Result&lt;char&gt; {\nlet ch = self.peek_char()?;\nself.input = &amp;self.input[ch.len_utf8()..];\nOk(ch)\n}\n// Parse the JSON identifier `true` or `false`.\nfn parse_bool(&amp;mut self) -&gt; Result&lt;bool&gt; {\nif self.input.starts_with(\"true\") {\nself.input = &amp;self.input[\"true\".len()..];\nOk(true)\n} else if self.input.starts_with(\"false\") {\nself.input = &amp;self.input[\"false\".len()..];\nOk(false)\n} else {\nErr(Error::ExpectedBoolean)\n}\n}\n// Parse a group of decimal digits as an unsigned integer of type T.\n//\n// This implementation is a bit too lenient, for example `001` is not\n// allowed in JSON. Also the various arithmetic operations can overflow and\n// panic or return bogus data. But it is good enough for example code!\nfn parse_unsigned&lt;T&gt;(&amp;mut self) -&gt; Result&lt;T&gt;\nwhere\nT: AddAssign&lt;T&gt; + MulAssign&lt;T&gt; + From&lt;u8&gt;,\n{\nlet mut int = match self.next_char()? {\nch @ '0'..='9' =&gt; T::from(ch as u8 - b'0'),\n_ =&gt; {\nreturn Err(Error::ExpectedInteger);\n}\n};\nloop {\nmatch self.input.chars().next() {\nSome(ch @ '0'..='9') =&gt; {\nself.input = &amp;self.input[1..];\nint *= T::from(10);\nint += T::from(ch as u8 - b'0');\n}\n_ =&gt; {\nreturn Ok(int);\n}\n}\n}\n}\n// Parse a possible minus sign followed by a group of decimal digits as a\n// signed integer of type T.\nfn parse_signed&lt;T&gt;(&amp;mut self) -&gt; Result&lt;T&gt;\nwhere\nT: Neg&lt;Output = T&gt; + AddAssign&lt;T&gt; + MulAssign&lt;T&gt; + From&lt;i8&gt;,\n{\n// Optional minus sign, delegate to `parse_unsigned`, negate if negative.\nunimplemented!()\n}\n// Parse a string until the next '\"' character.\n//\n// Makes no attempt to handle escape sequences. What did you expect? This is\n// example code!\nfn parse_string(&amp;mut self) -&gt; Result&lt;&amp;'de str&gt; {\nif self.next_char()? != '\"' {\nreturn Err(Error::ExpectedString);\n}\nmatch self.input.find('\"') {\nSome(len) =&gt; {\nlet s = &amp;self.input[..len];\nself.input = &amp;self.input[len + 1..];\nOk(s)\n}\nNone =&gt; Err(Error::Eof),\n}\n}\n}\nimpl&lt;'de, 'a&gt; de::Deserializer&lt;'de&gt; for &amp;'a mut Deserializer&lt;'de&gt; {\ntype Error = Error;\n// Look at the input data to decide what Serde data model type to\n// deserialize as. Not all data formats are able to support this operation.\n// Formats that support `deserialize_any` are known as self-describing.\nfn deserialize_any&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\nmatch self.peek_char()? {\n'n' =&gt; self.deserialize_unit(visitor),\n't' | 'f' =&gt; self.deserialize_bool(visitor),\n'\"' =&gt; self.deserialize_str(visitor),\n'0'..='9' =&gt; self.deserialize_u64(visitor),\n'-' =&gt; self.deserialize_i64(visitor),\n'[' =&gt; self.deserialize_seq(visitor),\n'{' =&gt; self.deserialize_map(visitor),\n_ =&gt; Err(Error::Syntax),\n}\n}\n// Uses the `parse_bool` parsing function defined above to read the JSON\n// identifier `true` or `false` from the input.\n//\n// Parsing refers to looking at the input and deciding that it contains the\n// JSON value `true` or `false`.\n//\n// Deserialization refers to mapping that JSON value into Serde's data\n// model by invoking one of the `Visitor` methods. In the case of JSON and\n// bool that mapping is straightforward so the distinction may seem silly,\n// but in other cases Deserializers sometimes perform non-obvious mappings.\n// For example the TOML format has a Datetime type and Serde's data model\n// does not. In the `toml` crate, a Datetime in the input is deserialized by\n// mapping it to a Serde data model \"struct\" type with a special name and a\n// single field containing the Datetime represented as a string.\nfn deserialize_bool&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\nvisitor.visit_bool(self.parse_bool()?)\n}\n// The `parse_signed` function is generic over the integer type `T` so here\n// it is invoked with `T=i8`. The next 8 methods are similar.\nfn deserialize_i8&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\nvisitor.visit_i8(self.parse_signed()?)\n}\nfn deserialize_i16&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\nvisitor.visit_i16(self.parse_signed()?)\n}\nfn deserialize_i32&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\nvisitor.visit_i32(self.parse_signed()?)\n}\nfn deserialize_i64&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\nvisitor.visit_i64(self.parse_signed()?)\n}\nfn deserialize_u8&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\nvisitor.visit_u8(self.parse_unsigned()?)\n}\nfn deserialize_u16&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\nvisitor.visit_u16(self.parse_unsigned()?)\n}\nfn deserialize_u32&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\nvisitor.visit_u32(self.parse_unsigned()?)\n}\nfn deserialize_u64&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\nvisitor.visit_u64(self.parse_unsigned()?)\n}\n// Float parsing is stupidly hard.\nfn deserialize_f32&lt;V&gt;(self, _visitor: V) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\nunimplemented!()\n}\n// Float parsing is stupidly hard.\nfn deserialize_f64&lt;V&gt;(self, _visitor: V) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\nunimplemented!()\n}\n// The `Serializer` implementation on the previous page serialized chars as\n// single-character strings so handle that representation here.\nfn deserialize_char&lt;V&gt;(self, _visitor: V) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\n// Parse a string, check that it is one character, call `visit_char`.\nunimplemented!()\n}\n// Refer to the \"Understanding deserializer lifetimes\" page for information\n// about the three deserialization flavors of strings in Serde.\nfn deserialize_str&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\nvisitor.visit_borrowed_str(self.parse_string()?)\n}\nfn deserialize_string&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\nself.deserialize_str(visitor)\n}\n// The `Serializer` implementation on the previous page serialized byte\n// arrays as JSON arrays of bytes. Handle that representation here.\nfn deserialize_bytes&lt;V&gt;(self, _visitor: V) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\nunimplemented!()\n}\nfn deserialize_byte_buf&lt;V&gt;(self, _visitor: V) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\nunimplemented!()\n}\n// An absent optional is represented as the JSON `null` and a present\n// optional is represented as just the contained value.\n//\n// As commented in `Serializer` implementation, this is a lossy\n// representation. For example the values `Some(())` and `None` both\n// serialize as just `null`. Unfortunately this is typically what people\n// expect when working with JSON. Other formats are encouraged to behave\n// more intelligently if possible.\nfn deserialize_option&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\nif self.input.starts_with(\"null\") {\nself.input = &amp;self.input[\"null\".len()..];\nvisitor.visit_none()\n} else {\nvisitor.visit_some(self)\n}\n}\n// In Serde, unit means an anonymous value containing no data.\nfn deserialize_unit&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\nif self.input.starts_with(\"null\") {\nself.input = &amp;self.input[\"null\".len()..];\nvisitor.visit_unit()\n} else {\nErr(Error::ExpectedNull)\n}\n}\n// Unit struct means a named value containing no data.\nfn deserialize_unit_struct&lt;V&gt;(\nself,\n_name: &amp;'static str,\nvisitor: V,\n) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\nself.deserialize_unit(visitor)\n}\n// As is done here, serializers are encouraged to treat newtype structs as\n// insignificant wrappers around the data they contain. That means not\n// parsing anything other than the contained value.\nfn deserialize_newtype_struct&lt;V&gt;(\nself,\n_name: &amp;'static str,\nvisitor: V,\n) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\nvisitor.visit_newtype_struct(self)\n}\n// Deserialization of compound types like sequences and maps happens by\n// passing the visitor an \"Access\" object that gives it the ability to\n// iterate through the data contained in the sequence.\nfn deserialize_seq&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\n// Parse the opening bracket of the sequence.\nif self.next_char()? == '[' {\n// Give the visitor access to each element of the sequence.\nlet value = visitor.visit_seq(CommaSeparated::new(self))?;\n// Parse the closing bracket of the sequence.\nif self.next_char()? == ']' {\nOk(value)\n} else {\nErr(Error::ExpectedArrayEnd)\n}\n} else {\nErr(Error::ExpectedArray)\n}\n}\n// Tuples look just like sequences in JSON. Some formats may be able to\n// represent tuples more efficiently.\n//\n// As indicated by the length parameter, the `Deserialize` implementation\n// for a tuple in the Serde data model is required to know the length of the\n// tuple before even looking at the input data.\nfn deserialize_tuple&lt;V&gt;(self, _len: usize, visitor: V) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\nself.deserialize_seq(visitor)\n}\n// Tuple structs look just like sequences in JSON.\nfn deserialize_tuple_struct&lt;V&gt;(\nself,\n_name: &amp;'static str,\n_len: usize,\nvisitor: V,\n) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\nself.deserialize_seq(visitor)\n}\n// Much like `deserialize_seq` but calls the visitors `visit_map` method\n// with a `MapAccess` implementation, rather than the visitor's `visit_seq`\n// method with a `SeqAccess` implementation.\nfn deserialize_map&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\n// Parse the opening brace of the map.\nif self.next_char()? == '{' {\n// Give the visitor access to each entry of the map.\nlet value = visitor.visit_map(CommaSeparated::new(self))?;\n// Parse the closing brace of the map.\nif self.next_char()? == '}' {\nOk(value)\n} else {\nErr(Error::ExpectedMapEnd)\n}\n} else {\nErr(Error::ExpectedMap)\n}\n}\n// Structs look just like maps in JSON.\n//\n// Notice the `fields` parameter - a \"struct\" in the Serde data model means\n// that the `Deserialize` implementation is required to know what the fields\n// are before even looking at the input data. Any key-value pairing in which\n// the fields cannot be known ahead of time is probably a map.\nfn deserialize_struct&lt;V&gt;(\nself,\n_name: &amp;'static str,\n_fields: &amp;'static [&amp;'static str],\nvisitor: V,\n) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\nself.deserialize_map(visitor)\n}\nfn deserialize_enum&lt;V&gt;(\nself,\n_name: &amp;'static str,\n_variants: &amp;'static [&amp;'static str],\nvisitor: V,\n) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\nif self.peek_char()? == '\"' {\n// Visit a unit variant.\nvisitor.visit_enum(self.parse_string()?.into_deserializer())\n} else if self.next_char()? == '{' {\n// Visit a newtype variant, tuple variant, or struct variant.\nlet value = visitor.visit_enum(Enum::new(self))?;\n// Parse the matching close brace.\nif self.next_char()? == '}' {\nOk(value)\n} else {\nErr(Error::ExpectedMapEnd)\n}\n} else {\nErr(Error::ExpectedEnum)\n}\n}\n// An identifier in Serde is the type that identifies a field of a struct or\n// the variant of an enum. In JSON, struct fields and enum variants are\n// represented as strings. In other formats they may be represented as\n// numeric indices.\nfn deserialize_identifier&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\nself.deserialize_str(visitor)\n}\n// Like `deserialize_any` but indicates to the `Deserializer` that it makes\n// no difference which `Visitor` method is called because the data is\n// ignored.\n//\n// Some deserializers are able to implement this more efficiently than\n// `deserialize_any`, for example by rapidly skipping over matched\n// delimiters without paying close attention to the data in between.\n//\n// Some formats are not able to implement this at all. Formats that can\n// implement `deserialize_any` and `deserialize_ignored_any` are known as\n// self-describing.\nfn deserialize_ignored_any&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\nself.deserialize_any(visitor)\n}\n}\n// In order to handle commas correctly when deserializing a JSON array or map,\n// we need to track whether we are on the first element or past the first\n// element.\nstruct CommaSeparated&lt;'a, 'de: 'a&gt; {\nde: &amp;'a mut Deserializer&lt;'de&gt;,\nfirst: bool,\n}\nimpl&lt;'a, 'de&gt; CommaSeparated&lt;'a, 'de&gt; {\nfn new(de: &amp;'a mut Deserializer&lt;'de&gt;) -&gt; Self {\nCommaSeparated {\nde,\nfirst: true,\n}\n}\n}\n// `SeqAccess` is provided to the `Visitor` to give it the ability to iterate\n// through elements of the sequence.\nimpl&lt;'de, 'a&gt; SeqAccess&lt;'de&gt; for CommaSeparated&lt;'a, 'de&gt; {\ntype Error = Error;\nfn next_element_seed&lt;T&gt;(&amp;mut self, seed: T) -&gt; Result&lt;Option&lt;T::Value&gt;&gt;\nwhere\nT: DeserializeSeed&lt;'de&gt;,\n{\n// Check if there are no more elements.\nif self.de.peek_char()? == ']' {\nreturn Ok(None);\n}\n// Comma is required before every element except the first.\nif !self.first &amp;&amp; self.de.next_char()? != ',' {\nreturn Err(Error::ExpectedArrayComma);\n}\nself.first = false;\n// Deserialize an array element.\nseed.deserialize(&amp;mut *self.de).map(Some)\n}\n}\n// `MapAccess` is provided to the `Visitor` to give it the ability to iterate\n// through entries of the map.\nimpl&lt;'de, 'a&gt; MapAccess&lt;'de&gt; for CommaSeparated&lt;'a, 'de&gt; {\ntype Error = Error;\nfn next_key_seed&lt;K&gt;(&amp;mut self, seed: K) -&gt; Result&lt;Option&lt;K::Value&gt;&gt;\nwhere\nK: DeserializeSeed&lt;'de&gt;,\n{\n// Check if there are no more entries.\nif self.de.peek_char()? == '}' {\nreturn Ok(None);\n}\n// Comma is required before every entry except the first.\nif !self.first &amp;&amp; self.de.next_char()? != ',' {\nreturn Err(Error::ExpectedMapComma);\n}\nself.first = false;\n// Deserialize a map key.\nseed.deserialize(&amp;mut *self.de).map(Some)\n}\nfn next_value_seed&lt;V&gt;(&amp;mut self, seed: V) -&gt; Result&lt;V::Value&gt;\nwhere\nV: DeserializeSeed&lt;'de&gt;,\n{\n// It doesn't make a difference whether the colon is parsed at the end\n// of `next_key_seed` or at the beginning of `next_value_seed`. In this\n// case the code is a bit simpler having it here.\nif self.de.next_char()? != ':' {\nreturn Err(Error::ExpectedMapColon);\n}\n// Deserialize a map value.\nseed.deserialize(&amp;mut *self.de)\n}\n}\nstruct Enum&lt;'a, 'de: 'a&gt; {\nde: &amp;'a mut Deserializer&lt;'de&gt;,\n}\nimpl&lt;'a, 'de&gt; Enum&lt;'a, 'de&gt; {\nfn new(de: &amp;'a mut Deserializer&lt;'de&gt;) -&gt; Self {\nEnum { de }\n}\n}\n// `EnumAccess` is provided to the `Visitor` to give it the ability to determine\n// which variant of the enum is supposed to be deserialized.\n//\n// Note that all enum deserialization methods in Serde refer exclusively to the\n// \"externally tagged\" enum representation.\nimpl&lt;'de, 'a&gt; EnumAccess&lt;'de&gt; for Enum&lt;'a, 'de&gt; {\ntype Error = Error;\ntype Variant = Self;\nfn variant_seed&lt;V&gt;(self, seed: V) -&gt; Result&lt;(V::Value, Self::Variant)&gt;\nwhere\nV: DeserializeSeed&lt;'de&gt;,\n{\n// The `deserialize_enum` method parsed a `{` character so we are\n// currently inside of a map. The seed will be deserializing itself from\n// the key of the map.\nlet val = seed.deserialize(&amp;mut *self.de)?;\n// Parse the colon separating map key from value.\nif self.de.next_char()? == ':' {\nOk((val, self))\n} else {\nErr(Error::ExpectedMapColon)\n}\n}\n}\n// `VariantAccess` is provided to the `Visitor` to give it the ability to see\n// the content of the single variant that it decided to deserialize.\nimpl&lt;'de, 'a&gt; VariantAccess&lt;'de&gt; for Enum&lt;'a, 'de&gt; {\ntype Error = Error;\n// If the `Visitor` expected this variant to be a unit variant, the input\n// should have been the plain string case handled in `deserialize_enum`.\nfn unit_variant(self) -&gt; Result&lt;()&gt; {\nErr(Error::ExpectedString)\n}\n// Newtype variants are represented in JSON as `{ NAME: VALUE }` so\n// deserialize the value here.\nfn newtype_variant_seed&lt;T&gt;(self, seed: T) -&gt; Result&lt;T::Value&gt;\nwhere\nT: DeserializeSeed&lt;'de&gt;,\n{\nseed.deserialize(self.de)\n}\n// Tuple variants are represented in JSON as `{ NAME: [DATA...] }` so\n// deserialize the sequence of data here.\nfn tuple_variant&lt;V&gt;(self, _len: usize, visitor: V) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\nde::Deserializer::deserialize_seq(self.de, visitor)\n}\n// Struct variants are represented in JSON as `{ NAME: { K: V, ... } }` so\n// deserialize the inner map here.\nfn struct_variant&lt;V&gt;(\nself,\n_fields: &amp;'static [&amp;'static str],\nvisitor: V,\n) -&gt; Result&lt;V::Value&gt;\nwhere\nV: Visitor&lt;'de&gt;,\n{\nde::Deserializer::deserialize_map(self.de, visitor)\n}\n}\n////////////////////////////////////////////////////////////////////////////////\n# macro_rules! not_actually_test {\n#     ($(#[test] $test:item)+) =&gt; {\n#         $($test)+\n#     }\n# }\n#\n# not_actually_test! {\n#[test]\nfn test_struct() {\n#[derive(Deserialize, PartialEq, Debug)]\nstruct Test {\nint: u32,\nseq: Vec&lt;String&gt;,\n}\nlet j = r#\"{\"int\":1,\"seq\":[\"a\",\"b\"]}\"#;\nlet expected = Test {\nint: 1,\nseq: vec![\"a\".to_owned(), \"b\".to_owned()],\n};\nassert_eq!(expected, from_str(j).unwrap());\n}\n#[test]\nfn test_enum() {\n#[derive(Deserialize, PartialEq, Debug)]\nenum E {\nUnit,\nNewtype(u32),\nTuple(u32, u32),\nStruct { a: u32 },\n}\nlet j = r#\"\"Unit\"\"#;\nlet expected = E::Unit;\nassert_eq!(expected, from_str(j).unwrap());\nlet j = r#\"{\"Newtype\":1}\"#;\nlet expected = E::Newtype(1);\nassert_eq!(expected, from_str(j).unwrap());\nlet j = r#\"{\"Tuple\":[1,2]}\"#;\nlet expected = E::Tuple(1, 2);\nassert_eq!(expected, from_str(j).unwrap());\nlet j = r#\"{\"Struct\":{\"a\":1}}\"#;\nlet expected = E::Struct { a: 1 };\nassert_eq!(expected, from_str(j).unwrap());\n}\n# }\n#\n# fn main() {\n#     test_struct();\n#     test_enum();\n# }\n</code></pre></p>"},{"location":"data-format/impl-serializer/","title":"Implementing a Serializer","text":"<p>This page gives a basic but functional implementation of a JSON serializer using Serde.</p> <p>The [<code>Serializer</code>] trait has a lot of methods but none of the ones in this implementation are complicated. Each method corresponds to one of the types of the Serde data model. The serializer is responsible for mapping the data model into the output representation, in this case JSON.</p> <p>Refer to the rustdoc of the <code>Serializer</code> trait for examples of how each method is used.</p> <p>!FILENAME src/ser.rs <pre><code># mod error {\n#     pub use serde::de::value::Error;\n#     pub type Result&lt;T&gt; = ::std::result::Result&lt;T, Error&gt;;\n# }\n#\nuse serde::{ser, Serialize};\nuse error::{Error, Result};\npub struct Serializer {\n// This string starts empty and JSON is appended as values are serialized.\noutput: String,\n}\n// By convention, the public API of a Serde serializer is one or more `to_abc`\n// functions such as `to_string`, `to_bytes`, or `to_writer` depending on what\n// Rust types the serializer is able to produce as output.\n//\n// This basic serializer supports only `to_string`.\npub fn to_string&lt;T&gt;(value: &amp;T) -&gt; Result&lt;String&gt;\nwhere\nT: Serialize,\n{\nlet mut serializer = Serializer {\noutput: String::new(),\n};\nvalue.serialize(&amp;mut serializer)?;\nOk(serializer.output)\n}\nimpl&lt;'a&gt; ser::Serializer for &amp;'a mut Serializer {\n// The output type produced by this `Serializer` during successful\n// serialization. Most serializers that produce text or binary output should\n// set `Ok = ()` and serialize into an `io::Write` or buffer contained\n// within the `Serializer` instance, as happens here. Serializers that build\n// in-memory data structures may be simplified by using `Ok` to propagate\n// the data structure around.\ntype Ok = ();\n// The error type when some error occurs during serialization.\ntype Error = Error;\n// Associated types for keeping track of additional state while serializing\n// compound data structures like sequences and maps. In this case no\n// additional state is required beyond what is already stored in the\n// Serializer struct.\ntype SerializeSeq = Self;\ntype SerializeTuple = Self;\ntype SerializeTupleStruct = Self;\ntype SerializeTupleVariant = Self;\ntype SerializeMap = Self;\ntype SerializeStruct = Self;\ntype SerializeStructVariant = Self;\n// Here we go with the simple methods. The following 12 methods receive one\n// of the primitive types of the data model and map it to JSON by appending\n// into the output string.\nfn serialize_bool(self, v: bool) -&gt; Result&lt;()&gt; {\nself.output += if v { \"true\" } else { \"false\" };\nOk(())\n}\n// JSON does not distinguish between different sizes of integers, so all\n// signed integers will be serialized the same and all unsigned integers\n// will be serialized the same. Other formats, especially compact binary\n// formats, may need independent logic for the different sizes.\nfn serialize_i8(self, v: i8) -&gt; Result&lt;()&gt; {\nself.serialize_i64(i64::from(v))\n}\nfn serialize_i16(self, v: i16) -&gt; Result&lt;()&gt; {\nself.serialize_i64(i64::from(v))\n}\nfn serialize_i32(self, v: i32) -&gt; Result&lt;()&gt; {\nself.serialize_i64(i64::from(v))\n}\n// Not particularly efficient but this is example code anyway. A more\n// performant approach would be to use the `itoa` crate.\nfn serialize_i64(self, v: i64) -&gt; Result&lt;()&gt; {\nself.output += &amp;v.to_string();\nOk(())\n}\nfn serialize_u8(self, v: u8) -&gt; Result&lt;()&gt; {\nself.serialize_u64(u64::from(v))\n}\nfn serialize_u16(self, v: u16) -&gt; Result&lt;()&gt; {\nself.serialize_u64(u64::from(v))\n}\nfn serialize_u32(self, v: u32) -&gt; Result&lt;()&gt; {\nself.serialize_u64(u64::from(v))\n}\nfn serialize_u64(self, v: u64) -&gt; Result&lt;()&gt; {\nself.output += &amp;v.to_string();\nOk(())\n}\nfn serialize_f32(self, v: f32) -&gt; Result&lt;()&gt; {\nself.serialize_f64(f64::from(v))\n}\nfn serialize_f64(self, v: f64) -&gt; Result&lt;()&gt; {\nself.output += &amp;v.to_string();\nOk(())\n}\n// Serialize a char as a single-character string. Other formats may\n// represent this differently.\nfn serialize_char(self, v: char) -&gt; Result&lt;()&gt; {\nself.serialize_str(&amp;v.to_string())\n}\n// This only works for strings that don't require escape sequences but you\n// get the idea. For example it would emit invalid JSON if the input string\n// contains a '\"' character.\nfn serialize_str(self, v: &amp;str) -&gt; Result&lt;()&gt; {\nself.output += \"\\\"\";\nself.output += v;\nself.output += \"\\\"\";\nOk(())\n}\n// Serialize a byte array as an array of bytes. Could also use a base64\n// string here. Binary formats will typically represent byte arrays more\n// compactly.\nfn serialize_bytes(self, v: &amp;[u8]) -&gt; Result&lt;()&gt; {\nuse serde::ser::SerializeSeq;\nlet mut seq = self.serialize_seq(Some(v.len()))?;\nfor byte in v {\nseq.serialize_element(byte)?;\n}\nseq.end()\n}\n// An absent optional is represented as the JSON `null`.\nfn serialize_none(self) -&gt; Result&lt;()&gt; {\nself.serialize_unit()\n}\n// A present optional is represented as just the contained value. Note that\n// this is a lossy representation. For example the values `Some(())` and\n// `None` both serialize as just `null`. Unfortunately this is typically\n// what people expect when working with JSON. Other formats are encouraged\n// to behave more intelligently if possible.\nfn serialize_some&lt;T&gt;(self, value: &amp;T) -&gt; Result&lt;()&gt;\nwhere\nT: ?Sized + Serialize,\n{\nvalue.serialize(self)\n}\n// In Serde, unit means an anonymous value containing no data. Map this to\n// JSON as `null`.\nfn serialize_unit(self) -&gt; Result&lt;()&gt; {\nself.output += \"null\";\nOk(())\n}\n// Unit struct means a named value containing no data. Again, since there is\n// no data, map this to JSON as `null`. There is no need to serialize the\n// name in most formats.\nfn serialize_unit_struct(self, _name: &amp;'static str) -&gt; Result&lt;()&gt; {\nself.serialize_unit()\n}\n// When serializing a unit variant (or any other kind of variant), formats\n// can choose whether to keep track of it by index or by name. Binary\n// formats typically use the index of the variant and human-readable formats\n// typically use the name.\nfn serialize_unit_variant(\nself,\n_name: &amp;'static str,\n_variant_index: u32,\nvariant: &amp;'static str,\n) -&gt; Result&lt;()&gt; {\nself.serialize_str(variant)\n}\n// As is done here, serializers are encouraged to treat newtype structs as\n// insignificant wrappers around the data they contain.\nfn serialize_newtype_struct&lt;T&gt;(\nself,\n_name: &amp;'static str,\nvalue: &amp;T,\n) -&gt; Result&lt;()&gt;\nwhere\nT: ?Sized + Serialize,\n{\nvalue.serialize(self)\n}\n// Note that newtype variant (and all of the other variant serialization\n// methods) refer exclusively to the \"externally tagged\" enum\n// representation.\n//\n// Serialize this to JSON in externally tagged form as `{ NAME: VALUE }`.\nfn serialize_newtype_variant&lt;T&gt;(\nself,\n_name: &amp;'static str,\n_variant_index: u32,\nvariant: &amp;'static str,\nvalue: &amp;T,\n) -&gt; Result&lt;()&gt;\nwhere\nT: ?Sized + Serialize,\n{\nself.output += \"{\";\nvariant.serialize(&amp;mut *self)?;\nself.output += \":\";\nvalue.serialize(&amp;mut *self)?;\nself.output += \"}\";\nOk(())\n}\n// Now we get to the serialization of compound types.\n//\n// The start of the sequence, each value, and the end are three separate\n// method calls. This one is responsible only for serializing the start,\n// which in JSON is `[`.\n//\n// The length of the sequence may or may not be known ahead of time. This\n// doesn't make a difference in JSON because the length is not represented\n// explicitly in the serialized form. Some serializers may only be able to\n// support sequences for which the length is known up front.\nfn serialize_seq(self, _len: Option&lt;usize&gt;) -&gt; Result&lt;Self::SerializeSeq&gt; {\nself.output += \"[\";\nOk(self)\n}\n// Tuples look just like sequences in JSON. Some formats may be able to\n// represent tuples more efficiently by omitting the length, since tuple\n// means that the corresponding `Deserialize implementation will know the\n// length without needing to look at the serialized data.\nfn serialize_tuple(self, len: usize) -&gt; Result&lt;Self::SerializeTuple&gt; {\nself.serialize_seq(Some(len))\n}\n// Tuple structs look just like sequences in JSON.\nfn serialize_tuple_struct(\nself,\n_name: &amp;'static str,\nlen: usize,\n) -&gt; Result&lt;Self::SerializeTupleStruct&gt; {\nself.serialize_seq(Some(len))\n}\n// Tuple variants are represented in JSON as `{ NAME: [DATA...] }`. Again\n// this method is only responsible for the externally tagged representation.\nfn serialize_tuple_variant(\nself,\n_name: &amp;'static str,\n_variant_index: u32,\nvariant: &amp;'static str,\n_len: usize,\n) -&gt; Result&lt;Self::SerializeTupleVariant&gt; {\nself.output += \"{\";\nvariant.serialize(&amp;mut *self)?;\nself.output += \":[\";\nOk(self)\n}\n// Maps are represented in JSON as `{ K: V, K: V, ... }`.\nfn serialize_map(self, _len: Option&lt;usize&gt;) -&gt; Result&lt;Self::SerializeMap&gt; {\nself.output += \"{\";\nOk(self)\n}\n// Structs look just like maps in JSON. In particular, JSON requires that we\n// serialize the field names of the struct. Other formats may be able to\n// omit the field names when serializing structs because the corresponding\n// Deserialize implementation is required to know what the keys are without\n// looking at the serialized data.\nfn serialize_struct(\nself,\n_name: &amp;'static str,\nlen: usize,\n) -&gt; Result&lt;Self::SerializeStruct&gt; {\nself.serialize_map(Some(len))\n}\n// Struct variants are represented in JSON as `{ NAME: { K: V, ... } }`.\n// This is the externally tagged representation.\nfn serialize_struct_variant(\nself,\n_name: &amp;'static str,\n_variant_index: u32,\nvariant: &amp;'static str,\n_len: usize,\n) -&gt; Result&lt;Self::SerializeStructVariant&gt; {\nself.output += \"{\";\nvariant.serialize(&amp;mut *self)?;\nself.output += \":{\";\nOk(self)\n}\n}\n// The following 7 impls deal with the serialization of compound types like\n// sequences and maps. Serialization of such types is begun by a Serializer\n// method and followed by zero or more calls to serialize individual elements of\n// the compound type and one call to end the compound type.\n//\n// This impl is SerializeSeq so these methods are called after `serialize_seq`\n// is called on the Serializer.\nimpl&lt;'a&gt; ser::SerializeSeq for &amp;'a mut Serializer {\n// Must match the `Ok` type of the serializer.\ntype Ok = ();\n// Must match the `Error` type of the serializer.\ntype Error = Error;\n// Serialize a single element of the sequence.\nfn serialize_element&lt;T&gt;(&amp;mut self, value: &amp;T) -&gt; Result&lt;()&gt;\nwhere\nT: ?Sized + Serialize,\n{\nif !self.output.ends_with('[') {\nself.output += \",\";\n}\nvalue.serialize(&amp;mut **self)\n}\n// Close the sequence.\nfn end(self) -&gt; Result&lt;()&gt; {\nself.output += \"]\";\nOk(())\n}\n}\n// Same thing but for tuples.\nimpl&lt;'a&gt; ser::SerializeTuple for &amp;'a mut Serializer {\ntype Ok = ();\ntype Error = Error;\nfn serialize_element&lt;T&gt;(&amp;mut self, value: &amp;T) -&gt; Result&lt;()&gt;\nwhere\nT: ?Sized + Serialize,\n{\nif !self.output.ends_with('[') {\nself.output += \",\";\n}\nvalue.serialize(&amp;mut **self)\n}\nfn end(self) -&gt; Result&lt;()&gt; {\nself.output += \"]\";\nOk(())\n}\n}\n// Same thing but for tuple structs.\nimpl&lt;'a&gt; ser::SerializeTupleStruct for &amp;'a mut Serializer {\ntype Ok = ();\ntype Error = Error;\nfn serialize_field&lt;T&gt;(&amp;mut self, value: &amp;T) -&gt; Result&lt;()&gt;\nwhere\nT: ?Sized + Serialize,\n{\nif !self.output.ends_with('[') {\nself.output += \",\";\n}\nvalue.serialize(&amp;mut **self)\n}\nfn end(self) -&gt; Result&lt;()&gt; {\nself.output += \"]\";\nOk(())\n}\n}\n// Tuple variants are a little different. Refer back to the\n// `serialize_tuple_variant` method above:\n//\n//    self.output += \"{\";\n//    variant.serialize(&amp;mut *self)?;\n//    self.output += \":[\";\n//\n// So the `end` method in this impl is responsible for closing both the `]` and\n// the `}`.\nimpl&lt;'a&gt; ser::SerializeTupleVariant for &amp;'a mut Serializer {\ntype Ok = ();\ntype Error = Error;\nfn serialize_field&lt;T&gt;(&amp;mut self, value: &amp;T) -&gt; Result&lt;()&gt;\nwhere\nT: ?Sized + Serialize,\n{\nif !self.output.ends_with('[') {\nself.output += \",\";\n}\nvalue.serialize(&amp;mut **self)\n}\nfn end(self) -&gt; Result&lt;()&gt; {\nself.output += \"]}\";\nOk(())\n}\n}\n// Some `Serialize` types are not able to hold a key and value in memory at the\n// same time so `SerializeMap` implementations are required to support\n// `serialize_key` and `serialize_value` individually.\n//\n// There is a third optional method on the `SerializeMap` trait. The\n// `serialize_entry` method allows serializers to optimize for the case where\n// key and value are both available simultaneously. In JSON it doesn't make a\n// difference so the default behavior for `serialize_entry` is fine.\nimpl&lt;'a&gt; ser::SerializeMap for &amp;'a mut Serializer {\ntype Ok = ();\ntype Error = Error;\n// The Serde data model allows map keys to be any serializable type. JSON\n// only allows string keys so the implementation below will produce invalid\n// JSON if the key serializes as something other than a string.\n//\n// A real JSON serializer would need to validate that map keys are strings.\n// This can be done by using a different Serializer to serialize the key\n// (instead of `&amp;mut **self`) and having that other serializer only\n// implement `serialize_str` and return an error on any other data type.\nfn serialize_key&lt;T&gt;(&amp;mut self, key: &amp;T) -&gt; Result&lt;()&gt;\nwhere\nT: ?Sized + Serialize,\n{\nif !self.output.ends_with('{') {\nself.output += \",\";\n}\nkey.serialize(&amp;mut **self)\n}\n// It doesn't make a difference whether the colon is printed at the end of\n// `serialize_key` or at the beginning of `serialize_value`. In this case\n// the code is a bit simpler having it here.\nfn serialize_value&lt;T&gt;(&amp;mut self, value: &amp;T) -&gt; Result&lt;()&gt;\nwhere\nT: ?Sized + Serialize,\n{\nself.output += \":\";\nvalue.serialize(&amp;mut **self)\n}\nfn end(self) -&gt; Result&lt;()&gt; {\nself.output += \"}\";\nOk(())\n}\n}\n// Structs are like maps in which the keys are constrained to be compile-time\n// constant strings.\nimpl&lt;'a&gt; ser::SerializeStruct for &amp;'a mut Serializer {\ntype Ok = ();\ntype Error = Error;\nfn serialize_field&lt;T&gt;(&amp;mut self, key: &amp;'static str, value: &amp;T) -&gt; Result&lt;()&gt;\nwhere\nT: ?Sized + Serialize,\n{\nif !self.output.ends_with('{') {\nself.output += \",\";\n}\nkey.serialize(&amp;mut **self)?;\nself.output += \":\";\nvalue.serialize(&amp;mut **self)\n}\nfn end(self) -&gt; Result&lt;()&gt; {\nself.output += \"}\";\nOk(())\n}\n}\n// Similar to `SerializeTupleVariant`, here the `end` method is responsible for\n// closing both of the curly braces opened by `serialize_struct_variant`.\nimpl&lt;'a&gt; ser::SerializeStructVariant for &amp;'a mut Serializer {\ntype Ok = ();\ntype Error = Error;\nfn serialize_field&lt;T&gt;(&amp;mut self, key: &amp;'static str, value: &amp;T) -&gt; Result&lt;()&gt;\nwhere\nT: ?Sized + Serialize,\n{\nif !self.output.ends_with('{') {\nself.output += \",\";\n}\nkey.serialize(&amp;mut **self)?;\nself.output += \":\";\nvalue.serialize(&amp;mut **self)\n}\nfn end(self) -&gt; Result&lt;()&gt; {\nself.output += \"}}\";\nOk(())\n}\n}\n////////////////////////////////////////////////////////////////////////////////\n# macro_rules! not_actually_test {\n#     ($(#[test] $test:item)+) =&gt; {\n#         $($test)+\n#     }\n# }\n#\n# not_actually_test! {\n#[test]\nfn test_struct() {\n#[derive(Serialize)]\nstruct Test {\nint: u32,\nseq: Vec&lt;&amp;'static str&gt;,\n}\nlet test = Test {\nint: 1,\nseq: vec![\"a\", \"b\"],\n};\nlet expected = r#\"{\"int\":1,\"seq\":[\"a\",\"b\"]}\"#;\nassert_eq!(to_string(&amp;test).unwrap(), expected);\n}\n#[test]\nfn test_enum() {\n#[derive(Serialize)]\nenum E {\nUnit,\nNewtype(u32),\nTuple(u32, u32),\nStruct { a: u32 },\n}\nlet u = E::Unit;\nlet expected = r#\"\"Unit\"\"#;\nassert_eq!(to_string(&amp;u).unwrap(), expected);\nlet n = E::Newtype(1);\nlet expected = r#\"{\"Newtype\":1}\"#;\nassert_eq!(to_string(&amp;n).unwrap(), expected);\nlet t = E::Tuple(1, 2);\nlet expected = r#\"{\"Tuple\":[1,2]}\"#;\nassert_eq!(to_string(&amp;t).unwrap(), expected);\nlet s = E::Struct { a: 1 };\nlet expected = r#\"{\"Struct\":{\"a\":1}}\"#;\nassert_eq!(to_string(&amp;s).unwrap(), expected);\n}\n# }\n#\n# fn main() {\n#     test_struct();\n#     test_enum();\n# }\n</code></pre></p>"},{"location":"examples/","title":"Examples","text":"<p>Structs and enums in JSON: The representation chosen by <code>serde_json</code> for structs and enums. Other human-readable data formats are encouraged to follow an analogous approach where possible.</p> <p>Enum representations: Externally tagged, internally tagged, adjacently tagged, and untagged ways of representing an enum in self-describing formats.</p> <p>Default value for a field: Some examples of the <code>#[serde(default)]</code> attribute.</p> <p>Handwritten generic type bounds: Some unusual scenarios in which Serde's derive infers the wrong generic type bounds. The impl bounds can be replaced with handwritten ones using the <code>#[serde(bound)]</code> attribute.</p> <p>Deserialize for custom map type: Detailed explanation of each step involved in deserializing a map.</p> <p>Array of values without buffering: Deserialize the maximum value of an array of integers without holding the whole array in memory at once. This approach can be adapted to handle a variety of other situations in which data needs to be processed while being deserialized instead of after.</p> <p>Serialize enum as number: A macro to impl <code>Serialize</code> and <code>Deserialize</code> for a C-like enum in a way that represents it as a <code>u64</code> across all data formats.</p> <p>Serialize fields as camelCase: One common application of the <code>#[serde(rename)]</code> attribute.</p> <p>Skip serializing field: Some examples of the <code>#[serde(skip_serializing)]</code> and <code>#[serde(skip_serializing_if)]</code> attributes.</p> <p>Derive for remote crate: Deriving <code>Serialize</code> and <code>Deserialize</code> implementations for a type in somebody else's crate.</p> <p>Manually deserialize struct: The long form of the <code>Deserialize</code> impl generated by derive for a simple struct.</p> <p>Discarding data: Using <code>IgnoredAny</code> to efficiently discard data from a deserializer.</p> <p>Transcode one format into another: Use the serde-transcode crate to stream input in one format to output in another format efficiently.</p> <p>Deserialize either a string or a struct: The <code>docker-compose.yml</code> configuration file has a \"build\" key which can be either a string or a struct.</p> <p>Convert error types: Map a Serde error from some format into a Serde error for some other format using <code>Error::custom</code>.</p> <p>Date in a custom format: Handle a <code>chrono</code> <code>DateTime</code> formatted with a custom string representation.</p>"},{"location":"examples/attr-bound/","title":"Handwritten generic type bounds","text":"<p>When deriving <code>Serialize</code> and <code>Deserialize</code> implementations for structs with generic type parameters, most of the time Serde is able to infer the correct trait bounds without help from the programmer. It uses several heuristics to guess the right bound, but most importantly it puts a bound of <code>T: Serialize</code> on every type parameter <code>T</code> that is part of a serialized field and a bound of <code>T: Deserialize</code> on every type parameter <code>T</code> that is part of a deserialized field. As with most heuristics, this is not always right and Serde provides an escape hatch to replace the automatically generated bound by one written by the programmer.</p> <p>!PLAYGROUND d2a50878ab69a5786f5a3a11a9de71ea <pre><code>use serde::{de, Deserialize, Deserializer};\nuse std::fmt::Display;\nuse std::str::FromStr;\n#[derive(Deserialize, Debug)]\nstruct Outer&lt;'a, S, T: 'a + ?Sized&gt; {\n// When deriving the Deserialize impl, Serde would want to generate a bound\n// `S: Deserialize` on the type of this field. But we are going to use the\n// type's `FromStr` impl instead of its `Deserialize` impl by going through\n// `deserialize_from_str`, so we override the automatically generated bound\n// by the one required for `deserialize_from_str`.\n#[serde(deserialize_with = \"deserialize_from_str\")]\n#[serde(bound(deserialize = \"S: FromStr, S::Err: Display\"))]\ns: S,\n// Here Serde would want to generate a bound `T: Deserialize`. That is a\n// stricter condition than is necessary. In fact, the `main` function below\n// uses T=str which does not implement Deserialize. We override the\n// automatically generated bound by a looser one.\n#[serde(bound(deserialize = \"Ptr&lt;'a, T&gt;: Deserialize&lt;'de&gt;\"))]\nptr: Ptr&lt;'a, T&gt;,\n}\n/// Deserialize a type `S` by deserializing a string, then using the `FromStr`\n/// impl of `S` to create the result. The generic type `S` is not required to\n/// implement `Deserialize`.\nfn deserialize_from_str&lt;'de, S, D&gt;(deserializer: D) -&gt; Result&lt;S, D::Error&gt;\nwhere\nS: FromStr,\nS::Err: Display,\nD: Deserializer&lt;'de&gt;,\n{\nlet s: String = Deserialize::deserialize(deserializer)?;\nS::from_str(&amp;s).map_err(de::Error::custom)\n}\n/// A pointer to `T` which may or may not own the data. When deserializing we\n/// always want to produce owned data.\n#[derive(Debug)]\nenum Ptr&lt;'a, T: 'a + ?Sized&gt; {\n# #[allow(dead_code)]\nRef(&amp;'a T),\nOwned(Box&lt;T&gt;),\n}\nimpl&lt;'de, 'a, T: 'a + ?Sized&gt; Deserialize&lt;'de&gt; for Ptr&lt;'a, T&gt;\nwhere\nBox&lt;T&gt;: Deserialize&lt;'de&gt;,\n{\nfn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Self, D::Error&gt;\nwhere\nD: Deserializer&lt;'de&gt;,\n{\nDeserialize::deserialize(deserializer).map(Ptr::Owned)\n}\n}\nfn main() {\nlet j = r#\"\n        {\n            \"s\": \"1234567890\",\n            \"ptr\": \"owned\"\n        }\n    \"#;\nlet result: Outer&lt;u64, str&gt; = serde_json::from_str(j).unwrap();\n// result = Outer { s: 1234567890, ptr: Owned(\"owned\") }\nprintln!(\"result = {:?}\", result);\n}\n</code></pre></p>"},{"location":"examples/attr-default/","title":"Default value for a field","text":"<p>!PLAYGROUND b238170d32f604295a1110ad912ef3ee <pre><code>use serde::Deserialize;\n#[derive(Deserialize, Debug)]\nstruct Request {\n// Use the result of a function as the default if \"resource\" is\n// not included in the input.\n#[serde(default = \"default_resource\")]\nresource: String,\n// Use the type's implementation of std::default::Default if\n// \"timeout\" is not included in the input.\n#[serde(default)]\ntimeout: Timeout,\n// Use a method from the type as the default if \"priority\" is not\n// included in the input. This may also be a trait method.\n#[serde(default = \"Priority::lowest\")]\npriority: Priority,\n}\nfn default_resource() -&gt; String {\n\"/\".to_string()\n}\n/// Timeout in seconds.\n#[derive(Deserialize, Debug)]\nstruct Timeout(u32);\nimpl Default for Timeout {\nfn default() -&gt; Self {\nTimeout(30)\n}\n}\n#[derive(Deserialize, Debug)]\nenum Priority { ExtraHigh, High, Normal, Low, ExtraLow }\nimpl Priority {\nfn lowest() -&gt; Self { Priority::ExtraLow }\n}\nfn main() {\nlet json = r#\"\n        [\n          {\n            \"resource\": \"/users\"\n          },\n          {\n            \"timeout\": 5,\n            \"priority\": \"High\"\n          }\n        ]\n    \"#;\nlet requests: Vec&lt;Request&gt; = serde_json::from_str(json).unwrap();\n// The first request has resource=\"/users\", timeout=30, priority=ExtraLow\nprintln!(\"{:?}\", requests[0]);\n// The second request has resource=\"/\", timeout=5, priority=High\nprintln!(\"{:?}\", requests[1]);\n}\n</code></pre></p>"},{"location":"examples/attr-flatten/","title":"Struct flattening","text":"<p>The <code>flatten</code> attribute inlines keys from a field into the parent struct. <code>flatten</code> may be used any number of times within the same struct. It is supported only within structs that have named fields, and the field to which it is applied must be a struct or map type.</p> <p>Note: <code>flatten</code> is not supported in combination with structs that use [<code>deny_unknown_fields</code>]. Neither the outer nor inner flattened struct should use that attribute.</p> <p>The <code>flatten</code> attribute serves the following two common use cases:</p>"},{"location":"examples/attr-flatten/#factor-out-frequently-grouped-keys","title":"Factor out frequently grouped keys","text":"<p>Consider a paginated API which returns a page of results along with pagination metadata that identifies how many results were requested, how far into the total set of results we are looking at, and how many results exist in total. If we are paging through a total of 1053 results 100 at a time, the third page may look like this.</p> <pre><code>{\n\"limit\": 100,\n\"offset\": 200,\n\"total\": 1053,\n\"users\": [\n{\"id\": \"49824073-979f-4814-be10-5ea416ee1c2f\", \"username\": \"john_doe\"},\n...\n]\n}\n</code></pre> <p>This same scheme with <code>\"limit\"</code> and <code>\"offset\"</code> and <code>\"total\"</code> fields may be shared across lots of different API queries. For example we may want paginated results when querying for users, for issues, for projects, etc.</p> <p>In this case it can be convenient to factor the common pagination metadata fields into a shared struct that can be flattened into each API response object.</p> <pre><code># use serde::{Serialize, Deserialize};\n#\n#[derive(Serialize, Deserialize)]\nstruct Pagination {\nlimit: u64,\noffset: u64,\ntotal: u64,\n}\n#[derive(Serialize, Deserialize)]\nstruct Users {\nusers: Vec&lt;User&gt;,\n#[serde(flatten)]\npagination: Pagination,\n}\n#\n# #[derive(Serialize, Deserialize)]\n# struct User;\n#\n# fn main() {}\n</code></pre>"},{"location":"examples/attr-flatten/#capture-additional-fields","title":"Capture additional fields","text":"<p>A field of map type can be flattened to hold additional data that is not captured by any other fields of the struct.</p> <pre><code>use std::collections::HashMap;\nuse serde::{Serialize, Deserialize};\nuse serde_json::Value;\n#[derive(Serialize, Deserialize)]\nstruct User {\nid: String,\nusername: String,\n#[serde(flatten)]\nextra: HashMap&lt;String, Value&gt;,\n}\n#\n# fn main() {}\n</code></pre> <p>For example if we fill the flattened <code>extra</code> field with the key <code>\"mascot\": \"Ferris\"</code>, it would serialize to the following JSON representation.</p> <pre><code>{\n\"id\": \"49824073-979f-4814-be10-5ea416ee1c2f\",\n\"username\": \"john_doe\",\n\"mascot\": \"Ferris\"\n}\n</code></pre> <p>Deserialization of this data would populate <code>\"mascot\"</code> back into the flattened <code>extra</code> field. This way additional data in an object can be collected for later processing.</p>"},{"location":"examples/attr-rename/","title":"Serialize fields as camelCase","text":"<p>!PLAYGROUND b2852ed8e696999ccd9d2ac668b848bf <pre><code>use serde::Serialize;\n#[derive(Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct Person {\nfirst_name: String,\nlast_name: String,\n}\nfn main() {\nlet person = Person {\nfirst_name: \"Graydon\".to_string(),\nlast_name: \"Hoare\".to_string(),\n};\nlet json = serde_json::to_string_pretty(&amp;person).unwrap();\n// Prints:\n//\n//    {\n//      \"firstName\": \"Graydon\",\n//      \"lastName\": \"Hoare\"\n//    }\nprintln!(\"{}\", json);\n}\n</code></pre></p>"},{"location":"examples/attr-skip-serializing/","title":"Skip serializing field","text":"<p>NOTE: Using <code>skip_serializing</code> does not skip deserializing the field. If you only add the <code>skip_serializing</code> attribute, and then attempt to deserialize the data, it will fail, as it will still attempt to deserialize the skipped field. Please use the <code>skip</code> attribute to skip both serializing and deserializing (see Field Attributes: <code>skip</code>). Likewise, use <code>skip_deserializing</code> to skip deserializing only.</p> <p>!PLAYGROUND b65f4a90bb11285574a1917b0f5e10aa <pre><code>use serde::Serialize;\nuse std::collections::BTreeMap as Map;\n#[derive(Serialize)]\nstruct Resource {\n// Always serialized.\nname: String,\n// Never serialized.\n#[serde(skip_serializing)]\n# #[allow(dead_code)]\nhash: String,\n// Use a method to decide whether the field should be skipped.\n#[serde(skip_serializing_if = \"Map::is_empty\")]\nmetadata: Map&lt;String, String&gt;,\n}\nfn main() {\nlet resources = vec![\nResource {\nname: \"Stack Overflow\".to_string(),\nhash: \"b6469c3f31653d281bbbfa6f94d60fea130abe38\".to_string(),\nmetadata: Map::new(),\n},\nResource {\nname: \"GitHub\".to_string(),\nhash: \"5cb7a0c47e53854cd00e1a968de5abce1c124601\".to_string(),\nmetadata: {\nlet mut metadata = Map::new();\nmetadata.insert(\"headquarters\".to_string(),\n\"San Francisco\".to_string());\nmetadata\n},\n},\n];\nlet json = serde_json::to_string_pretty(&amp;resources).unwrap();\n// Prints:\n//\n//    [\n//      {\n//        \"name\": \"Stack Overflow\"\n//      },\n//      {\n//        \"name\": \"GitHub\",\n//        \"metadata\": {\n//          \"headquarters\": \"San Francisco\"\n//        }\n//      }\n//    ]\nprintln!(\"{}\", json);\n}\n</code></pre></p>"},{"location":"examples/convert-error/","title":"Converting error types","text":"<p>In some situations, values in some format must be contained inside of data in some other format. For example an IAM policy in Terraform is represented as a JSON string contained inside of an HCL config.</p> <p>It would be simple to treat the inner value as just a String, but if we are going to be manipulating both the inner and outer value it can often be convenient to serialize and deserialize them all at once.</p> <p>One occasional stumbling block in such situations is correctly handling errors. The two formats may (probably do) have different Error types, so some conversion is necessary.</p> <p>This example shows a simplified HCL resource containing a simplified IAM policy. The policy document is represented as a JSON string when serialized.</p> <pre><code>use serde::{Serialize, Deserialize};\n#[derive(Serialize, Deserialize)]\nstruct Resource {\nname: String,\n#[serde(with = \"as_json_string\")]\npolicy: Policy,\n}\n#[derive(Serialize, Deserialize)]\nstruct Policy {\neffect: String,\naction: String,\nresource: String,\n}\n// Serialize and deserialize logic for dealing with nested values represented as\n// JSON strings.\nmod as_json_string {\nuse serde_json;\nuse serde::ser::{Serialize, Serializer};\nuse serde::de::{Deserialize, DeserializeOwned, Deserializer};\n// Serialize to a JSON string, then serialize the string to the output\n// format.\npub fn serialize&lt;T, S&gt;(value: &amp;T, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;\nwhere\nT: Serialize,\nS: Serializer,\n{\nuse serde::ser::Error;\nlet j = serde_json::to_string(value).map_err(Error::custom)?;\nj.serialize(serializer)\n}\n// Deserialize a string from the input format, then deserialize the content\n// of that string as JSON.\npub fn deserialize&lt;'de, T, D&gt;(deserializer: D) -&gt; Result&lt;T, D::Error&gt;\nwhere\nT: DeserializeOwned,\nD: Deserializer&lt;'de&gt;,\n{\nuse serde::de::Error;\nlet j = String::deserialize(deserializer)?;\nserde_json::from_str(&amp;j).map_err(Error::custom)\n}\n}\nfn main() {\nlet resource = Resource {\nname: \"test_policy\".to_owned(),\npolicy: Policy {\neffect: \"Allow\".to_owned(),\naction: \"s3:ListBucket\".to_owned(),\nresource: \"arn:aws:s3:::example_bucket\".to_owned(),\n},\n};\nlet y = serde_yaml::to_string(&amp;resource).unwrap();\nprintln!(\"{}\", y);\n}\n</code></pre>"},{"location":"examples/custom-date-format/","title":"Date in a custom format","text":"<p>This uses the <code>chrono</code> crate to serialize and deserialize JSON data containing a custom date format. The <code>with</code> attribute is used to provide the logic for handling the custom representation.</p> <p>!PLAYGROUND 7185eb211a4822ce97184ae25fedda91 <pre><code>use chrono::{DateTime, Utc};\nuse serde::{Serialize, Deserialize};\n#[derive(Serialize, Deserialize, Debug)]\npub struct StructWithCustomDate {\n// DateTime supports Serde out of the box, but uses RFC3339 format. Provide\n// some custom logic to make it use our desired format.\n#[serde(with = \"my_date_format\")]\npub timestamp: DateTime&lt;Utc&gt;,\n// Any other fields in the struct.\npub bidder: String,\n}\nmod my_date_format {\nuse chrono::{DateTime, Utc, TimeZone};\nuse serde::{self, Deserialize, Serializer, Deserializer};\nconst FORMAT: &amp;'static str = \"%Y-%m-%d %H:%M:%S\";\n// The signature of a serialize_with function must follow the pattern:\n//\n//    fn serialize&lt;S&gt;(&amp;T, S) -&gt; Result&lt;S::Ok, S::Error&gt;\n//    where\n//        S: Serializer\n//\n// although it may also be generic over the input types T.\npub fn serialize&lt;S&gt;(\ndate: &amp;DateTime&lt;Utc&gt;,\nserializer: S,\n) -&gt; Result&lt;S::Ok, S::Error&gt;\nwhere\nS: Serializer,\n{\nlet s = format!(\"{}\", date.format(FORMAT));\nserializer.serialize_str(&amp;s)\n}\n// The signature of a deserialize_with function must follow the pattern:\n//\n//    fn deserialize&lt;'de, D&gt;(D) -&gt; Result&lt;T, D::Error&gt;\n//    where\n//        D: Deserializer&lt;'de&gt;\n//\n// although it may also be generic over the output types T.\npub fn deserialize&lt;'de, D&gt;(\ndeserializer: D,\n) -&gt; Result&lt;DateTime&lt;Utc&gt;, D::Error&gt;\nwhere\nD: Deserializer&lt;'de&gt;,\n{\nlet s = String::deserialize(deserializer)?;\nUtc.datetime_from_str(&amp;s, FORMAT).map_err(serde::de::Error::custom)\n}\n}\nfn main() {\nlet json_str = r#\"\n      {\n        \"timestamp\": \"2017-02-16 21:54:30\",\n        \"bidder\": \"Skrillex\"\n      }\n    \"#;\nlet data: StructWithCustomDate = serde_json::from_str(json_str).unwrap();\nprintln!(\"{:#?}\", data);\nlet serialized = serde_json::to_string_pretty(&amp;data).unwrap();\nprintln!(\"{}\", serialized);\n}\n</code></pre></p>"},{"location":"examples/deserialize-map/","title":"Implement Deserialize for a custom map type","text":"<p>!PLAYGROUND 72f10ca685c08f8afeb618efdabfed6a <pre><code>use std::fmt;\nuse std::marker::PhantomData;\nuse serde::de::{Deserialize, Deserializer, Visitor, MapAccess};\n#\n# struct MyMap&lt;K, V&gt;(PhantomData&lt;K&gt;, PhantomData&lt;V&gt;);\n#\n# impl&lt;K, V&gt; MyMap&lt;K, V&gt; {\n#     fn with_capacity(_: usize) -&gt; Self {\n#         unimplemented!()\n#     }\n#\n#     fn insert(&amp;mut self, _: K, _: V) {\n#         unimplemented!()\n#     }\n# }\n// A Visitor is a type that holds methods that a Deserializer can drive\n// depending on what is contained in the input data.\n//\n// In the case of a map we need generic type parameters K and V to be\n// able to set the output type correctly, but don't require any state.\n// This is an example of a \"zero sized type\" in Rust. The PhantomData\n// keeps the compiler from complaining about unused generic type\n// parameters.\nstruct MyMapVisitor&lt;K, V&gt; {\nmarker: PhantomData&lt;fn() -&gt; MyMap&lt;K, V&gt;&gt;\n}\nimpl&lt;K, V&gt; MyMapVisitor&lt;K, V&gt; {\nfn new() -&gt; Self {\nMyMapVisitor {\nmarker: PhantomData\n}\n}\n}\n// This is the trait that Deserializers are going to be driving. There\n// is one method for each type of data that our type knows how to\n// deserialize from. There are many other methods that are not\n// implemented here, for example deserializing from integers or strings.\n// By default those methods will return an error, which makes sense\n// because we cannot deserialize a MyMap from an integer or string.\nimpl&lt;'de, K, V&gt; Visitor&lt;'de&gt; for MyMapVisitor&lt;K, V&gt;\nwhere\nK: Deserialize&lt;'de&gt;,\nV: Deserialize&lt;'de&gt;,\n{\n// The type that our Visitor is going to produce.\ntype Value = MyMap&lt;K, V&gt;;\n// Format a message stating what data this Visitor expects to receive.\nfn expecting(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {\nformatter.write_str(\"a very special map\")\n}\n// Deserialize MyMap from an abstract \"map\" provided by the\n// Deserializer. The MapAccess input is a callback provided by\n// the Deserializer to let us see each entry in the map.\nfn visit_map&lt;M&gt;(self, mut access: M) -&gt; Result&lt;Self::Value, M::Error&gt;\nwhere\nM: MapAccess&lt;'de&gt;,\n{\nlet mut map = MyMap::with_capacity(access.size_hint().unwrap_or(0));\n// While there are entries remaining in the input, add them\n// into our map.\nwhile let Some((key, value)) = access.next_entry()? {\nmap.insert(key, value);\n}\nOk(map)\n}\n}\n// This is the trait that informs Serde how to deserialize MyMap.\nimpl&lt;'de, K, V&gt; Deserialize&lt;'de&gt; for MyMap&lt;K, V&gt;\nwhere\nK: Deserialize&lt;'de&gt;,\nV: Deserialize&lt;'de&gt;,\n{\nfn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Self, D::Error&gt;\nwhere\nD: Deserializer&lt;'de&gt;,\n{\n// Instantiate our Visitor and ask the Deserializer to drive\n// it over the input data, resulting in an instance of MyMap.\ndeserializer.deserialize_map(MyMapVisitor::new())\n}\n}\n#\n# fn main() {}\n</code></pre></p>"},{"location":"examples/deserialize-struct/","title":"Manually implementing Deserialize for a struct","text":"<p>Only when derive is not getting the job done.</p> <p>The <code>Deserialize</code> impl below corresponds to the following struct:</p> <pre><code># #[allow(dead_code)]\nstruct Duration {\nsecs: u64,\nnanos: u32,\n}\n#\n# fn main() {}\n</code></pre> <p>Deserializing a struct is somewhat more complicated than deserializing a map in order to avoid allocating a String to hold the field names. Instead there is a <code>Field</code> enum which is deserialized from a <code>&amp;str</code>.</p> <p>The implementation supports two possible ways that a struct may be represented by a data format: as a seq like in Postcard, and as a map like in JSON.</p> <p>!PLAYGROUND 2e212d29e38110fc3d8f22ff920712be <pre><code>use std::fmt;\nuse serde::de::{self, Deserialize, Deserializer, Visitor, SeqAccess, MapAccess};\n# #[allow(dead_code)]\n# struct Duration {\n#     secs: u64,\n#     nanos: u32,\n# }\n#\n# impl Duration {\n#     fn new(_: u64, _: u32) -&gt; Self {\n#         unimplemented!()\n#     }\n# }\n#\nimpl&lt;'de&gt; Deserialize&lt;'de&gt; for Duration {\nfn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Self, D::Error&gt;\nwhere\nD: Deserializer&lt;'de&gt;,\n{\nenum Field { Secs, Nanos }\n// This part could also be generated independently by:\n//\n//    #[derive(Deserialize)]\n//    #[serde(field_identifier, rename_all = \"lowercase\")]\n//    enum Field { Secs, Nanos }\nimpl&lt;'de&gt; Deserialize&lt;'de&gt; for Field {\nfn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Field, D::Error&gt;\nwhere\nD: Deserializer&lt;'de&gt;,\n{\nstruct FieldVisitor;\nimpl&lt;'de&gt; Visitor&lt;'de&gt; for FieldVisitor {\ntype Value = Field;\nfn expecting(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {\nformatter.write_str(\"`secs` or `nanos`\")\n}\nfn visit_str&lt;E&gt;(self, value: &amp;str) -&gt; Result&lt;Field, E&gt;\nwhere\nE: de::Error,\n{\nmatch value {\n\"secs\" =&gt; Ok(Field::Secs),\n\"nanos\" =&gt; Ok(Field::Nanos),\n_ =&gt; Err(de::Error::unknown_field(value, FIELDS)),\n}\n}\n}\ndeserializer.deserialize_identifier(FieldVisitor)\n}\n}\nstruct DurationVisitor;\nimpl&lt;'de&gt; Visitor&lt;'de&gt; for DurationVisitor {\ntype Value = Duration;\nfn expecting(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {\nformatter.write_str(\"struct Duration\")\n}\nfn visit_seq&lt;V&gt;(self, mut seq: V) -&gt; Result&lt;Duration, V::Error&gt;\nwhere\nV: SeqAccess&lt;'de&gt;,\n{\nlet secs = seq.next_element()?\n.ok_or_else(|| de::Error::invalid_length(0, &amp;self))?;\nlet nanos = seq.next_element()?\n.ok_or_else(|| de::Error::invalid_length(1, &amp;self))?;\nOk(Duration::new(secs, nanos))\n}\nfn visit_map&lt;V&gt;(self, mut map: V) -&gt; Result&lt;Duration, V::Error&gt;\nwhere\nV: MapAccess&lt;'de&gt;,\n{\nlet mut secs = None;\nlet mut nanos = None;\nwhile let Some(key) = map.next_key()? {\nmatch key {\nField::Secs =&gt; {\nif secs.is_some() {\nreturn Err(de::Error::duplicate_field(\"secs\"));\n}\nsecs = Some(map.next_value()?);\n}\nField::Nanos =&gt; {\nif nanos.is_some() {\nreturn Err(de::Error::duplicate_field(\"nanos\"));\n}\nnanos = Some(map.next_value()?);\n}\n}\n}\nlet secs = secs.ok_or_else(|| de::Error::missing_field(\"secs\"))?;\nlet nanos = nanos.ok_or_else(|| de::Error::missing_field(\"nanos\"))?;\nOk(Duration::new(secs, nanos))\n}\n}\nconst FIELDS: &amp;'static [&amp;'static str] = &amp;[\"secs\", \"nanos\"];\ndeserializer.deserialize_struct(\"Duration\", FIELDS, DurationVisitor)\n}\n}\n#\n# fn main() {}\n</code></pre></p>"},{"location":"examples/enum-number/","title":"Serialize enum as number","text":"<p>The [serde_repr] crate provides alternative derive macros that derive the same Serialize and Deserialize traits but delegate to the underlying representation of a C-like enum. This allows C-like enums to be formatted as integers rather than strings in JSON, for example.</p> <pre><code>[dependencies]\nserde = \"1.0\"\nserde_json = \"1.0\"\nserde_repr = \"0.1\"\n</code></pre> <pre><code>use serde_repr::*;\n#[derive(Serialize_repr, Deserialize_repr, PartialEq, Debug)]\n#[repr(u8)]\nenum SmallPrime {\nTwo = 2,\nThree = 3,\nFive = 5,\nSeven = 7,\n}\nfn main() {\nuse SmallPrime::*;\nlet nums = vec![Two, Three, Five, Seven];\n// Prints [2,3,5,7]\nprintln!(\"{}\", serde_json::to_string(&amp;nums).unwrap());\nassert_eq!(Two, serde_json::from_str(\"2\").unwrap());\n}\n</code></pre>"},{"location":"examples/enum-representations/","title":"Enum representations","text":"<p>Consider the following enum type:</p> <pre><code># use serde::{Serialize, Deserialize};\n#\n# type Params = ();\n# type Value = ();\n#\n#[derive(Serialize, Deserialize)]\nenum Message {\nRequest { id: String, method: String, params: Params },\nResponse { id: String, result: Value },\n}\n#\n# fn main() {}\n</code></pre>"},{"location":"examples/enum-representations/#externally-tagged","title":"Externally tagged","text":"<p>The default representation for this enum in Serde is called the externally tagged enum representation. Written in JSON syntax it looks like:</p> <pre><code>{\"Request\": {\"id\": \"...\", \"method\": \"...\", \"params\": {...}}}\n</code></pre> <p>The externally tagged representation is characterized by being able to know which variant we are dealing with before beginning to parse the content of the variant. This property allows it to work across a broad range of text and binary formats. The <code>Serializer::serialize_*_variant</code> and <code>Deserializer::deserialize_enum</code> methods use an externally tagged representation.</p> <p>This representation can handle any type of variant: struct variants like above, tuple variants, newtype variants, and unit variants.</p> <p>In JSON and other self-describing formats, the externally tagged representation is often not ideal for readability. Serde provides attributes to select three other possible representations.</p>"},{"location":"examples/enum-representations/#internally-tagged","title":"Internally tagged","text":"<pre><code># use serde::{Serialize, Deserialize};\n#\n# type Params = ();\n# type Value = ();\n#\n#[derive(Serialize, Deserialize)]\n#[serde(tag = \"type\")]\nenum Message {\nRequest { id: String, method: String, params: Params },\nResponse { id: String, result: Value },\n}\n#\n# fn main() {}\n</code></pre> <p>Written in JSON syntax, the internally tagged representation looks like this:</p> <pre><code>{\"type\": \"Request\", \"id\": \"...\", \"method\": \"...\", \"params\": {...}}\n</code></pre> <p>The tag identifying which variant we are dealing with is now inside of the content, next to any other fields of the variant. This representation is common in Java libraries.</p> <p>This representation works for struct variants, newtype variants containing structs or maps, and unit variants but does not work for enums containing tuple variants. Using a <code>#[serde(tag = \"...\")]</code> attribute on an enum containing a tuple variant is an error at compile time.</p>"},{"location":"examples/enum-representations/#adjacently-tagged","title":"Adjacently tagged","text":"<pre><code># use serde::{Serialize, Deserialize};\n#\n# type Inline = ();\n#\n#[derive(Serialize, Deserialize)]\n#[serde(tag = \"t\", content = \"c\")]\nenum Block {\nPara(Vec&lt;Inline&gt;),\nStr(String),\n}\n#\n# fn main() {}\n</code></pre> <p>This representation is common in the Haskell world. Written in JSON syntax:</p> <pre><code>{\"t\": \"Para\", \"c\": [{...}, {...}]}\n{\"t\": \"Str\", \"c\": \"the string\"}\n</code></pre> <p>The tag and the content are adjacent to each other as two fields within the same object.</p>"},{"location":"examples/enum-representations/#untagged","title":"Untagged","text":"<pre><code># use serde::{Serialize, Deserialize};\n#\n# type Params = ();\n# type Value = ();\n#\n#[derive(Serialize, Deserialize)]\n#[serde(untagged)]\nenum Message {\nRequest { id: String, method: String, params: Params },\nResponse { id: String, result: Value },\n}\n#\n# fn main() {}\n</code></pre> <p>Written in JSON syntax, the untagged representation looks like this:</p> <pre><code>{\"id\": \"...\", \"method\": \"...\", \"params\": {...}}\n</code></pre> <p>There is no explicit tag identifying which variant the data contains. Serde will try to match the data against each variant in order and the first one that deserializes successfully is the one returned.</p> <p>This representation can handle enums containing any type of variant.</p> <p>As another example of an untagged enum, this enum can be deserialized from either an integer or an array of two strings:</p> <pre><code># use serde::{Serialize, Deserialize};\n#\n#[derive(Serialize, Deserialize)]\n#[serde(untagged)]\nenum Data {\nInteger(u64),\nPair(String, String),\n}\n#\n# fn main() {}\n</code></pre>"},{"location":"examples/ignored-any/","title":"Discarding data","text":"<p>The [<code>IgnoredAny</code>] type gives an efficient way of discarding data from a deserializer.</p> <p>Think of this like <code>serde_json::Value</code> in that it can be deserialized from any type, except that it does not store any information about the data that gets deserialized.</p> <pre><code>use std::fmt;\nuse std::marker::PhantomData;\nuse serde::de::{\nself, Deserialize, DeserializeSeed, Deserializer, Visitor, SeqAccess,\nIgnoredAny,\n};\nuse serde_json::json;\n// A seed that can be used to deserialize only the `n`th element of a sequence\n// while efficiently discarding elements of any type before or after index `n`.\n//\n// For example to deserialize only the element at index 3:\n//\n//    NthElement::new(3).deserialize(deserializer)\npub struct NthElement&lt;T&gt; {\nn: usize,\nmarker: PhantomData&lt;fn() -&gt; T&gt;,\n}\nimpl&lt;T&gt; NthElement&lt;T&gt; {\npub fn new(n: usize) -&gt; Self {\nNthElement {\nn: n,\nmarker: PhantomData,\n}\n}\n}\nimpl&lt;'de, T&gt; Visitor&lt;'de&gt; for NthElement&lt;T&gt;\nwhere\nT: Deserialize&lt;'de&gt;,\n{\ntype Value = T;\nfn expecting(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {\nwrite!(formatter, \"a sequence in which we care about element {}\", self.n)\n}\nfn visit_seq&lt;V&gt;(self, mut seq: V) -&gt; Result&lt;Self::Value, V::Error&gt;\nwhere\nV: SeqAccess&lt;'de&gt;,\n{\n// Skip over the first `n` elements.\nfor i in 0..self.n {\n// It is an error if the sequence ends before we get to element `n`.\nif seq.next_element::&lt;IgnoredAny&gt;()?.is_none() {\nreturn Err(de::Error::invalid_length(i, &amp;self));\n}\n}\n// Deserialize the one we care about.\nlet nth = seq.next_element()?\n.ok_or_else(|| de::Error::invalid_length(self.n, &amp;self))?;\n// Skip over any remaining elements in the sequence after `n`.\nwhile let Some(IgnoredAny) = seq.next_element()? {\n// ignore\n}\nOk(nth)\n}\n}\nimpl&lt;'de, T&gt; DeserializeSeed&lt;'de&gt; for NthElement&lt;T&gt;\nwhere\nT: Deserialize&lt;'de&gt;,\n{\ntype Value = T;\nfn deserialize&lt;D&gt;(self, deserializer: D) -&gt; Result&lt;Self::Value, D::Error&gt;\nwhere\nD: Deserializer&lt;'de&gt;,\n{\ndeserializer.deserialize_seq(self)\n}\n}\nfn main() {\nlet array = json!([\"a\", \"b\", \"c\", \"d\", \"e\"]);\nlet nth: String = NthElement::new(3).deserialize(&amp;array).unwrap();\nprintln!(\"{}\", nth);\nassert_eq!(nth, array[3]);\n}\n</code></pre>"},{"location":"examples/json/","title":"Structs and enums in JSON","text":"<p>A Serde <code>Serializer</code> is responsible for selecting the convention by which Rust structs and enums are represented in that format. Here are the conventions selected by the <code>serde_json</code> data format. For consistency, other human-readable formats are encouraged to develop analogous conventions where possible.</p> <pre><code># #![allow(dead_code, unused_variables)]\n#\n# fn main() {\n#\nstruct W {\na: i32,\nb: i32,\n}\nlet w = W { a: 0, b: 0 }; // Represented as `{\"a\":0,\"b\":0}`\nstruct X(i32, i32);\nlet x = X(0, 0); // Represented as `[0,0]`\nstruct Y(i32);\nlet y = Y(0); // Represented as just the inner value `0`\nstruct Z;\nlet z = Z; // Represented as `null`\nenum E {\nW { a: i32, b: i32 },\nX(i32, i32),\nY(i32),\nZ,\n}\nlet w = E::W { a: 0, b: 0 }; // Represented as `{\"W\":{\"a\":0,\"b\":0}}`\nlet x = E::X(0, 0);          // Represented as `{\"X\":[0,0]}`\nlet y = E::Y(0);             // Represented as `{\"Y\":0}`\nlet z = E::Z;                // Represented as `\"Z\"`\n#\n# }\n</code></pre>"},{"location":"examples/remote-derive/","title":"Deriving De/Serialize for type in a different crate","text":"<p>Rust's orphan rule requires that either the trait or the type for which you are implementing the trait must be defined in the same crate as the impl, so it is not possible to implement <code>Serialize</code> and <code>Deserialize</code> for a type in a different crate directly.</p> <pre><code>- use serde::Serialize;\n- use other_crate::Duration;\n-\n- // Not allowed by orphan rule.\n- impl Serialize for Duration {\n-     /* ... */\n- }\n</code></pre> <p>To work around this, Serde provides a way of deriving <code>Serialize</code> and <code>Deserialize</code> implementations for types in other people's crates. The only catch is that you have to provide a definition of the type for Serde's derive to process. At compile time, Serde will check that all the fields in the definition you provided match the fields in the remote type.</p> <p>!PLAYGROUND 0a344c9dfc4cf965e66125ebdfbc48b8 <pre><code>// Pretend that this is somebody else's crate, not a module.\nmod other_crate {\n// Neither Serde nor the other crate provides Serialize and Deserialize\n// impls for this struct.\npub struct Duration {\npub secs: i64,\npub nanos: i32,\n}\n}\n////////////////////////////////////////////////////////////////////////////////\nuse other_crate::Duration;\nuse serde::{Serialize, Deserialize};\n// Serde calls this the definition of the remote type. It is just a copy of the\n// remote data structure. The `remote` attribute gives the path to the actual\n// type we intend to derive code for.\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"Duration\")]\nstruct DurationDef {\nsecs: i64,\nnanos: i32,\n}\n// Now the remote type can be used almost like it had its own Serialize and\n// Deserialize impls all along. The `with` attribute gives the path to the\n// definition for the remote type. Note that the real type of the field is the\n// remote type, not the definition type.\n#[derive(Serialize, Deserialize)]\nstruct Process {\ncommand_line: String,\n#[serde(with = \"DurationDef\")]\nwall_time: Duration,\n}\n#\n# fn main() {}\n</code></pre></p> <p>If the remote type is a struct with all public fields or an enum, that's all there is to it. If the remote type is a struct with one or more private fields, getters must be provided for the private fields and a conversion must be provided to construct the remote type.</p> <p>!PLAYGROUND 02b8513dfb060b6580f998bac5a04a1a <pre><code>// Pretend that this is somebody else's crate, not a module.\nmod other_crate {\n// Neither Serde nor the other crate provides Serialize and Deserialize\n// impls for this struct. Oh, and the fields are private.\npub struct Duration {\nsecs: i64,\nnanos: i32,\n}\nimpl Duration {\npub fn new(secs: i64, nanos: i32) -&gt; Self {\nDuration { secs: secs, nanos: nanos }\n}\npub fn seconds(&amp;self) -&gt; i64 {\nself.secs\n}\npub fn subsec_nanos(&amp;self) -&gt; i32 {\nself.nanos\n}\n}\n}\n////////////////////////////////////////////////////////////////////////////////\nuse other_crate::Duration;\nuse serde::{Serialize, Deserialize};\n// Provide getters for every private field of the remote struct. The getter must\n// return either `T` or `&amp;T` where `T` is the type of the field.\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"Duration\")]\nstruct DurationDef {\n#[serde(getter = \"Duration::seconds\")]\nsecs: i64,\n#[serde(getter = \"Duration::subsec_nanos\")]\nnanos: i32,\n}\n// Provide a conversion to construct the remote type.\nimpl From&lt;DurationDef&gt; for Duration {\nfn from(def: DurationDef) -&gt; Duration {\nDuration::new(def.secs, def.nanos)\n}\n}\n#[derive(Serialize, Deserialize)]\nstruct Process {\ncommand_line: String,\n#[serde(with = \"DurationDef\")]\nwall_time: Duration,\n}\n#\n# fn main() {}\n</code></pre></p>"},{"location":"examples/remote-derive/#invoking-the-remote-impl-directly","title":"Invoking the remote impl directly","text":"<p>As shown above, the remote impl is intended to be invoked through a <code>#[serde(with = \"...\")]</code> attribute on a field of some other struct.</p> <p>Invoking the remote impl directly, such as if this is the top-level type being serialized or deserialized, is somewhat more complicated because of the orphan rules as mentioned. The code ultimately generated by these remote derives are not <code>Serialize</code> and <code>Deserialize</code> impls but associated functions with the same signature.</p> <pre><code># #![allow(dead_code)]\n#\n# use serde::Deserialize;\n#\n# struct Duration {\n#     secs: i64,\n#     nanos: i32,\n# }\n#\n// Technically this derive does not produce a Deserialize impl for Duration, nor\n// a Deserialize impl for DurationDef.\n//\n// Instead it produces a deserialization method DurationDef::deserialize whose\n// return type is Duration. The method has the same signature as a Deserialize\n// impl for Duration would have but is not a Deserialize impl.\n#[derive(Deserialize)]\n#[serde(remote = \"Duration\")]\nstruct DurationDef {\nsecs: i64,\nnanos: i32,\n}\n#\n# fn main() {}\n</code></pre> <p>Knowing this, the generated method can be invoked directly by passing a <code>Deserializer</code> implementation.</p> <p>!PLAYGROUND 29cadbd640a231d5703564a666b0bc85 <pre><code># #![allow(dead_code)]\n#\n# use serde::Deserialize;\n#\n# struct Duration;\n#\n# #[derive(Deserialize)]\n# #[serde(remote = \"Duration\")]\n# struct DurationDef;\n#\n# fn try_main(j: &amp;str) -&gt; Result&lt;Duration, serde_json::Error&gt; {\nlet mut de = serde_json::Deserializer::from_str(j);\nlet dur = DurationDef::deserialize(&amp;mut de)?;\n// `dur` has type Duration\n#     Ok(dur)\n# }\n#\n# fn main() {}\n</code></pre></p> <p>Alternatively we can write a top-level newtype wrapper as a private helper for deserializing the remote type.</p> <p>!PLAYGROUND 159da6ebf3a3573b8bd7f3bc2246026c <pre><code># #![allow(dead_code)]\n#\n# use serde::Deserialize;\n#\n# struct Duration;\n#\n# #[derive(Deserialize)]\n# #[serde(remote = \"Duration\")]\n# struct DurationDef;\n#\n# fn try_main(j: &amp;str) -&gt; Result&lt;Duration, serde_json::Error&gt; {\n#[derive(Deserialize)]\nstruct Helper(#[serde(with = \"DurationDef\")] Duration);\nlet dur = serde_json::from_str(j).map(|Helper(dur)| dur)?;\n// `dur` has type Duration\n#     Ok(dur)\n# }\n#\n# fn main() {}\n</code></pre></p>"},{"location":"examples/stream-array/","title":"Process an array of values without buffering into a Vec","text":"<p>Suppose we have an array of integers and we want to figure out the maximum value without holding the whole array in memory all at once. This approach can be adapted to handle a variety of other situations in which data needs to be processed while being deserialized instead of after.</p> <p>!PLAYGROUND 270186a56b8321704dc45001fdfa3c92 <pre><code>use serde::{Deserialize, Deserializer};\nuse serde::de::{self, Visitor, SeqAccess};\nuse std::{cmp, fmt};\nuse std::marker::PhantomData;\n#[derive(Deserialize)]\nstruct Outer {\n# #[allow(dead_code)]\nid: String,\n// Deserialize this field by computing the maximum value of a sequence\n// (JSON array) of values.\n#[serde(deserialize_with = \"deserialize_max\")]\n// Despite the struct field being named `max_value`, it is going to come\n// from a JSON field called `values`.\n#[serde(rename(deserialize = \"values\"))]\nmax_value: u64,\n}\n/// Deserialize the maximum of a sequence of values. The entire sequence\n/// is not buffered into memory as it would be if we deserialize to Vec&lt;T&gt;\n/// and then compute the maximum later.\n///\n/// This function is generic over T which can be any type that implements\n/// Ord. Above, it is used with T=u64.\nfn deserialize_max&lt;'de, T, D&gt;(deserializer: D) -&gt; Result&lt;T, D::Error&gt;\nwhere\nT: Deserialize&lt;'de&gt; + Ord,\nD: Deserializer&lt;'de&gt;,\n{\nstruct MaxVisitor&lt;T&gt;(PhantomData&lt;fn() -&gt; T&gt;);\nimpl&lt;'de, T&gt; Visitor&lt;'de&gt; for MaxVisitor&lt;T&gt;\nwhere\nT: Deserialize&lt;'de&gt; + Ord,\n{\n/// Return type of this visitor. This visitor computes the max of a\n/// sequence of values of type T, so the type of the maximum is T.\ntype Value = T;\nfn expecting(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {\nformatter.write_str(\"a nonempty sequence of numbers\")\n}\nfn visit_seq&lt;S&gt;(self, mut seq: S) -&gt; Result&lt;T, S::Error&gt;\nwhere\nS: SeqAccess&lt;'de&gt;,\n{\n// Start with max equal to the first value in the seq.\nlet mut max = seq.next_element()?.ok_or_else(||\n// Cannot take the maximum of an empty seq.\nde::Error::custom(\"no values in seq when looking for maximum\")\n)?;\n// Update the max while there are additional values.\nwhile let Some(value) = seq.next_element()? {\nmax = cmp::max(max, value);\n}\nOk(max)\n}\n}\n// Create the visitor and ask the deserializer to drive it. The\n// deserializer will call visitor.visit_seq() if a seq is present in\n// the input data.\nlet visitor = MaxVisitor(PhantomData);\ndeserializer.deserialize_seq(visitor)\n}\nfn main() {\nlet j = r#\"\n        {\n          \"id\": \"demo-deserialize-max\",\n          \"values\": [\n            256,\n            100,\n            384,\n            314,\n            271\n          ]\n        }\n    \"#;\nlet out: Outer = serde_json::from_str(j).unwrap();\n// Prints \"max value: 384\"\nprintln!(\"max value: {}\", out.max_value);\n}\n</code></pre></p>"},{"location":"examples/string-or-struct/","title":"Deserialize either a string or a struct","text":"<p>The <code>docker-compose.yml</code> configuration file has a \"build\" key which can be either a string or a struct.</p> <pre><code>build: ./dir\n# --- or ---\nbuild:\ncontext: ./dir\ndockerfile: Dockerfile-alternate\nargs:\nbuildno: 1\n</code></pre> <p>The configuration file uses the same pattern in other places as well, typically where a previously existing string field has been expanded to handle more complex data.</p> <p>We can use Rust's <code>FromStr</code> trait and Serde's <code>deserialize_with</code> attribute to handle this pattern in a general way.</p> <pre><code>use std::collections::BTreeMap as Map;\nuse std::fmt;\nuse std::marker::PhantomData;\nuse std::str::FromStr;\nuse serde::{Deserialize, Deserializer};\nuse serde::de::{self, Visitor, MapAccess};\nuse void::Void;\nfn main() {\nlet build_string = \"\n        build: ./dir\n    \";\nlet service: Service = serde_yaml::from_str(build_string).unwrap();\n// context=\"./dir\"\n// dockerfile=None\n// args={}\nprintln!(\"{:?}\", service);\nlet build_struct = \"\n        build:\n          context: ./dir\n          dockerfile: Dockerfile-alternate\n          args:\n            buildno: '1'\n    \";\nlet service: Service = serde_yaml::from_str(build_struct).unwrap();\n// context=\"./dir\"\n// dockerfile=Some(\"Dockerfile-alternate\")\n// args={\"buildno\": \"1\"}\nprintln!(\"{:?}\", service);\n}\n#[derive(Debug, Deserialize)]\nstruct Service {\n// The `string_or_struct` function delegates deserialization to a type's\n// `FromStr` impl if given a string, and to the type's `Deserialize` impl if\n// given a struct. The function is generic over the field type T (here T is\n// `Build`) so it can be reused for any field that implements both `FromStr`\n// and `Deserialize`.\n#[serde(deserialize_with = \"string_or_struct\")]\nbuild: Build,\n}\n#[derive(Debug, Deserialize)]\nstruct Build {\n// This is the only required field.\ncontext: String,\ndockerfile: Option&lt;String&gt;,\n// When `args` is not present in the input, this attribute tells Serde to\n// use `Default::default()` which in this case is an empty map. See the\n// \"default value for a field\" example for more about `#[serde(default)]`.\n#[serde(default)]\nargs: Map&lt;String, String&gt;,\n}\n// The `string_or_struct` function uses this impl to instantiate a `Build` if\n// the input file contains a string and not a struct. According to the\n// docker-compose.yml documentation, a string by itself represents a `Build`\n// with just the `context` field set.\n//\n// &gt; `build` can be specified either as a string containing a path to the build\n// &gt; context, or an object with the path specified under context and optionally\n// &gt; dockerfile and args.\nimpl FromStr for Build {\n// This implementation of `from_str` can never fail, so use the impossible\n// `Void` type as the error type.\ntype Err = Void;\nfn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {\nOk(Build {\ncontext: s.to_string(),\ndockerfile: None,\nargs: Map::new(),\n})\n}\n}\nfn string_or_struct&lt;'de, T, D&gt;(deserializer: D) -&gt; Result&lt;T, D::Error&gt;\nwhere\nT: Deserialize&lt;'de&gt; + FromStr&lt;Err = Void&gt;,\nD: Deserializer&lt;'de&gt;,\n{\n// This is a Visitor that forwards string types to T's `FromStr` impl and\n// forwards map types to T's `Deserialize` impl. The `PhantomData` is to\n// keep the compiler from complaining about T being an unused generic type\n// parameter. We need T in order to know the Value type for the Visitor\n// impl.\nstruct StringOrStruct&lt;T&gt;(PhantomData&lt;fn() -&gt; T&gt;);\nimpl&lt;'de, T&gt; Visitor&lt;'de&gt; for StringOrStruct&lt;T&gt;\nwhere\nT: Deserialize&lt;'de&gt; + FromStr&lt;Err = Void&gt;,\n{\ntype Value = T;\nfn expecting(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {\nformatter.write_str(\"string or map\")\n}\nfn visit_str&lt;E&gt;(self, value: &amp;str) -&gt; Result&lt;T, E&gt;\nwhere\nE: de::Error,\n{\nOk(FromStr::from_str(value).unwrap())\n}\nfn visit_map&lt;M&gt;(self, map: M) -&gt; Result&lt;T, M::Error&gt;\nwhere\nM: MapAccess&lt;'de&gt;,\n{\n// `MapAccessDeserializer` is a wrapper that turns a `MapAccess`\n// into a `Deserializer`, allowing it to be used as the input to T's\n// `Deserialize` implementation. T then deserializes itself using\n// the entries from the map visitor.\nDeserialize::deserialize(de::value::MapAccessDeserializer::new(map))\n}\n}\ndeserializer.deserialize_any(StringOrStruct(PhantomData))\n}\n</code></pre>"},{"location":"examples/transcode/","title":"Transcode one format into another","text":"<p>The <code>serde-transcode</code> crate provides functionality to \"transcode\" from an arbitrary Serde <code>Deserializer</code> to an arbitrary Serde <code>Serializer</code> without needing to collect the entire input into an intermediate form in memory. This provides a fully general way to convert any self-describing Serde data format into any other Serde data format in a memory-efficient streaming way.</p> <p>For example you could transcode a stream of JSON data into a stream of CBOR data, or transcode unformatted JSON into its pretty-printed form.</p> <p>This example implements the equivalent of Go's <code>json.Compact</code> function which removes insignificant whitespace from a JSON string in a streaming way.</p> <pre><code>use std::io;\nfn main() {\n// A JSON input with plenty of whitespace.\nlet input = r#\"\n      {\n        \"a boolean\": true,\n        \"an array\": [3, 2, 1]\n      }\n    \"#;\n// A JSON deserializer. You can use any Serde Deserializer here.\nlet mut deserializer = serde_json::Deserializer::from_str(input);\n// A compacted JSON serializer. You can use any Serde Serializer here.\nlet mut serializer = serde_json::Serializer::new(io::stdout());\n// Prints `{\"a boolean\":true,\"an array\":[3,2,1]}` to stdout.\n// This line works with any self-describing Deserializer and any Serializer.\nserde_transcode::transcode(&amp;mut deserializer, &amp;mut serializer).unwrap();\n}\n</code></pre>"}]}